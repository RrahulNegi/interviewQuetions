SAGA :-

It is a sequence of local transactions.

-Each Transaction of a particular service is treated as a local transaction, so we have a may sequence of local transaction.
-Each local transaction update data within single service
-Transaction can be sequential of parrallel
-Two types of SAGA pattern :
1- Event based(Choreography based)
2- Orchestration base 

1)Event based :-
-in this each MS generate an event and other services will listning of events.
Example UI service will customer will select the stock and it will generated an event message like "Select Stock()" this event base msg will be listien by Stock Srevice and it will then call payment service and generate even message "Do Payment()". Similarly Payment service listen the event and call FeedBack Service and generating event msg "Payment Cnf()" and then feed back service generate an event like sucssesfull payment or failure and finaly the UI service will listen the evenet generated by feedback.Here it is a simple one to one event based services.

- It may happen one of MS creating an event and one or more MS is listing the event this can generated cyclic dependencies between MS

-Events are domain based i.e it based on business of MS
-Each local transactionon successful completion publishes domain event that in turn trigger local transaction trigger in next services

-Lets consider a senario like if Payment get failed so payment Service will generate an event like "Payment failed()" it will be listen by feedback service which in return genrate an event like "Stock Purchase failed()" and it will be listen by UI service.


2)Orchestration (Command Based):-

-In this MS dosnt intract with each other but insted of it has a common Orchestration services 
-Customer select an stock so UI will generate an event "Buy Stock()" which will then listen by Orchestrator Service which then call Stock service and generate event "Select Stock()" when stock is selected succsessfully this service then generate "Stock Selected()" 
which then listen by Orchestrator service which then generate event "Do Payment()" which will be then listen by the Payment Service after sucessful of payment it generate event "Payment cnf()" then listen by Orchestrator service. whichthen generate event "Payment Done()" this listen by feedback service which then it will send msg "Stock Putrchased()" to Orchestrator service.

- Lets assume thatif we have a payment failed so payment services generated msg "Payment failed()" to Orchestrator and then Orchestrator will generate msg to FeedBack service "Payment failure()" and feedback service return msg to Orchestrator that "Stock Purchased fail " then Orchestrator service generate command called "Initiate Refund()" or it can be listen by Payment Service or any other service where logic of Refund is written.

- Lets suppose "Initate Refund()" get failed here we can have Retry Mechanism like limitaion of three. if it agin failed we can store the state of transaction i DB or messsage broker kafka and after sometime we can re try it.


Q) Disadvantage of Microservice

-) individual deployment of all MS
-)if any mS fails so we have to debug all MS step by step to knw y it failed.
-)We should have multiple level of autherization

Q) If  we have n no of MS and we have many autherization in it if some MS failed so how will u identify the reason ?

-first of all we have to redirect all the logs to splunk/Kibana/ElasticSearch and with each request from diffrent MS we will add a co-relation id which comes with the header of MS, if something gets failed we can find the logs from the splunk/kibana/ElastcSerach on basis of that co-relation id.
-if some MS get failed to run so for this we can put a health check for all MS and it can send mail that this MS is failing for that particular reason or we can get the data from splukn/kibana using logs

Q) Best Practices of Microservice?
-We can docakarise it 
-seprate build for each MS like MS1 can go in jenkins MS2 buid with nOde.js n deployed in many cloud like amazon or google cloud.
-Individual Db for all MS

Q)Technologies stack used to deploye the MS?
-depends on technology we used like MS1 Node.js MS2 php MS3 Spring etc


Q)How to restrict apllications for accessing thos MS?

-> MS communicate using HTTPS/HTTP using Rest APi
->All api is stateless beocoz inside load balancer similarv type of MS can be their like n no of MS1 so if request came so i dont want to preserve it becoz next req for same MS1 can be comes from another port so it cant get handeled.

-Authentication like we have multiple layes of MS

Q) How UI intract MS
-Client Browser we use CDN for loading all photos and static page
-USing js we can call MS api


Q)Microservice Logging ?

Lets Take MS1, MS2, MS3, these has its own logs we then pass these MS logs then fit to "logsstash" and then it transfer data to ElasticSearch using a pipeline and then we can find all MS logs in kibana

ElasticSearch :- Its a Nosql dB USE TO STORE INPUT/LOGS

logstash :- Its a log pipeline tool that acccsps input/logs from various sourcews and export the data into various targets

kibana :- Its a UI layer which will help developer to monitor logs


Q)Microservices communication?
1)Synchronus calls :-Calling MS syncronus call and waits for response it can be done using rest and http calls.
-easy to call and handel and in thi swe get responses real time.
-Disadvantage :- @) services avalability i.e what happend when some service down and we cant get response from service. @)Response time :- if MS1 calling MS2---> mS3--->MS4 so it will give late response

2)Asyncchronos way :- In this we use queue and MS send msg in queue and MS2 will listine to the queue and wrk according to it.
-if MS2 goes down so it will not effect the MS1 since when MS2 will comes up so it will process all the data inside the queue.

Advantage :-
-Faster API we making asycn calls
-Services are decouple
-works even when services are down

Disadvantages :-
-Complex design 
-Process latency
-Monitoring cost 

Q) Microservices RestTemplate vs WebClient ?

Q) Scaling of Microservice?
 
Like in ecom we have many srvices but major load is on search and product is more as mostly user search amny product and buy a few . So how to scale the loads in these  services one of the concept is cube like in cubes has three diffrent dimensions like wise 
x:- Horizontal scaling, y:-Functional Scaling, z:-Data Partesining

1)Fuctional scaling : Like we have a MS Product and search we can divide these into more small MS like MS1 - Listing of product, MS2- searching of product MS3-Pagination so we have divided into small parts

2)Data Partition :- We can scale by partion the data of a MS  just like RDMS
suppose we have a user service so we want to scale using Data Partioning. so lets we have a server handel User names staring with A-z so we can create another server who can handel data A-C and another C to G etc..

3) Horizontal scaling :- like we have a service product-search so in this we can run the duplicate copy of same server like SP in Server1 same in Server2 .... ServerN


Q)Service Discovery in Microservice?

-We dont want to hardcode all the sevices adress(Port,ip adrress) so if some service want to communicate with other servics so we use using SErvice Discovery its a pattern from where we can discover other services network adrress. So for this we use Service Registery its like a database which has lit of services and its network adress. 
-The microservices itself regester its Network and address to Service registory.
-if one of the instance goes down so network address we have is old so every x no of mins or sec the MS keeps on updating its so every time we have latest address of MS.
- For third party MS The service registry will constantl ask the MS to tell its adrress and then update the adress. So now how did MS knows whome to ask. MS will constanly lsting the server and as server keep on clustering the new nodes it came to knw which new MS is added.
-SR know how many instances of registry is running how it responding or nt

Discovery:-- In this we access all of the info in the registry if client want to access the particular MS so it will go to Service Registry and ask for latest network address of any given network

Q) Circuit breaking in microservices?

MS1--->MS2---->MS3  if all servics are available its work well and if any service is not available at a partiulcar time like if MS3 fails then If MS2 will not get response with MS3 and then it will throw Error response to MS1 so this is not good as we dont want to send back the error as response we want to handel it in better way.
-Suppose we have a retry machanism of 5 times in MS2, and MS3 is down so MS2 will try 5 times to get the response from MS3 so it will make situation more bad.
So to overcome such situation we use circuit-breaker in the MS so each MS have Circuit breaker it will come to knw ther service we just called is returning errors and it also make a note on which service how many times returning error.
Featur of Circuit breaker:-
1)Cached response:- we can configuer the circuit breaker in such a way that it hold the previous succesfull response return by MS3 and when the service falis it wiull return that cached response and MS1 will get 200 as response  insted of error from MS3.

2)Redirect to suplementray services of fallback memecanism:- its take an example our MS3 is video processing service and if MS3 is falied so the circuit breaker MS2 will redirect the request to third party backup service which will in return send the some video processing service.

3) Recover:- MS3 is fallling for past 2-3 times so MS2 circuit breaker will not send request to MS3 again and it will use above 2 method Cache/fallback and leave the MS3 for recovering.

Q) Service Mesh in microservices?

Problem:- we have MS1 ---->MS2----->MS3 and MS4 so lets assume we having more then one instacnees of MS1 , MS2 and MS3 and if MS1 try to contact with MS2 we have do all load balancing and do service discovery to find the nerwork address n all and we have to collect metriz like what is response time, how many was pass or fail etc and who is going to collect all services. or we will do timeout or do circuit reaker etc.
So their should be one places we put all timeout, circuit breaking etc so we have to do this thing in all MS.

Problem 2:- if we use Eureka service discovery to register and discover the MS's and this make the service-registry a crucial part and this server need to be reliable.

Problem 3:-Load balancing with multiple instnse.

Problem 3- We have a MS1 which handels all the traffic of request and we want to diverge the traffic to another instance of MS of version V1.1 and ensure that our code and request dosnt get effected

Problem 4:-Flow of application goes to diffrent MS so how to debug each Microservices so for this we use spring cloud sleuth which add a special request-id with each MS so we can easily debug it.

Problem Security:-
-How to ensure each service is usiing https so we have to add certificates and also ensure it get renewed on diffenit period of time. 
-How do u ensure that MS1 talking with MS2 and MS3 not MS4.  

So thats where service mesh cames in picture so its moto is Do not burden codes with all these infrastructure related decisions.
so mesh is one more component whch will run with all MS and handel all the above things . it can be a Virtual machine or a docker part. So MS server deployed so we have also depolyed the service mesh also. It use sidecart pattern i.e for every MS running their must be a sevice mesh is running.
This also impelemnts proxy design pattern

MS1 has its program called sidecar similarly MS2 has a program sidecar so when ever MS1 want to talk to MS2 it will be communicating using sidecar so all proxy and all properties are added in side car.
Lets we have a control tower wich manage all sidecar this control tower has all the configuration regarding proxies,loadbancing,certificates, Traffice handeling etc. like if we want to send 80% of request so MS1 v1.0 and rest to MS1 v1.1 so we have to call control plane/tower and it will handel all the things.
Features :-
1)Contrl Plane :- Centralized hub which acts like a panal which configure all the proxy which is side loaded with all the microservices and its every sinstance.
2)Data plane:- its a grp of proxies the imp part is this proxies dosnt knw presence of other proxy they work alone. all the rquest hapeing in data plane.
Control plane just configure all proxies.

Q)Points remember while deployment of microservices?

1)Scalability n throughput
2)Reliable and avilable
3)Isolation :- One service dosnt really effect other.
4)Resorce limit :- we have to specify how much CPU time or memory wil each service will take and it wont allowed to take more then it.
5)Monitor :- We need to monitor all depolyment services
6)Cost Effective

a)Multiple Service per host :- Running multiple services in single virtual machine or server. Thsese services may or may not use same server. We can scale out all we have to do add more VM or server load balance the colne of service.
Advantages :-
- Efficenet in resource utilization :- one or more services dealing with more traffic
Efficenet resourse utilization of hardware.

- Faster deployement:- we can deploye more then one services in one server so its musch faster.

Disadvantages :-
-Poor isolation:- since more then one service running in single server so it might happen they can disturb each other like if one is trying save a file in a dir and other may led to delete it.

-No resource limit :- MS1 is consumming all the resources and it not leaving any hardware resources for other service

-Dependency Conflict :- if two MS is on java so one MS1 using one version of jar and another service is using another version of same jar so it cause dependency conflict.

b) service per VM/container :-

we can deploye one MS in one VM/Container for scaling out we can add one more VM and run same MS so for this we can have many images for MS and use in diffrent VM.

avantage :-
-Isolation and secure
-Mangeable
-Faste
-Auto scaling


Disdavantage :-
-slow(NM only)
-Not efficient (VM only)
-Not soo secure (Containers)

c)Serverless :-

No servers involve in deployement i.e we needs sevre like google cloud or AWS. So we login to cnsole so they give a page where we paste the code and once u do it our api is running in cloud provider and they trigger code using http function and after processing it gives the response . It can also get triggered on basis of event also.
The API gateway also provide by cloud so we just have to define thet path.
How serveless manage scaling :- Cloud scale this function as its sees many request is comming.cloud will takecare of it.

Adv :-
-Focus on code
-No worries of scaling
- Pay as u go

Disadvantages :-
- Runtime support
- Expensive
- Vendor lock
- Debugging pain
-


