1) Spring Boot @Bean Annotation Example

The @Bean annotation indicates that a method produces a bean to be managed by the Spring container. 

The @Bean annotation is usually declared in the Configuration class to create Spring Bean definitions.

@Bean Annotation Example
In order to demonstrate the usage of @Bean annotation, let's create a couple of Java classes.
Student and Address
class Student{
    private Address address;

    public Student(Address address){
        this.address = address;
    }

    public void print(){
        System.out.println("Student class method called ...");
        address.print();
    }
}

class Address{

    public void print(){
        System.out.println("Address class method called ...");
    }
}

AppConfig Class
Next, let's create a Java configuration class annotated with @Configuration annotation. Within this class, let's create bean definitions using @Bean annotation.
@Configuration
class AppConfig{

    @Bean
    public Address address(){
        return new Address();
    }

    @Bean
    public Student student(){
        return new Student(address());
    }
}
Bean Names
By default, the bean name is the same as the method name. We can specify the bean names using @Bean(name = 
AppConfig Class
Next, let's create a Java configuration class annotated with @Configuration annotation. Within this class, let's create bean definitions using @Bean annotation.
@Configuration
class AppConfig{

    @Bean
    public Address address(){
        return new Address();
    }

    @Bean
    public Student student(){
        return new Student(address());
    }
}
Bean Names
By default, the bean name is the same as the method name. We can specify the bean names using @Bean(name = “beanName”).

For example:

    @Bean(name = "addressBean")
    public Address address(){
        return new Address();
    }

    @Bean(name = "studentBean")
    public Student student(){
        return new Student(address());
    }
Define Mulitple Bean Names
We can also specify multiple names for a single Spring bean. 

For example:
    @Bean(name = {"studentBean", "studentDemo", "studentComponent"})
    public Student student(){
        return new Student(address());
    }
Next, we can retrieve the student Spring bean object using any of these bean names. For example:
Student student = (Student) applicationContext.getBean("studentBean");
Or 
Student student = (Student) applicationContext.getBean("studentDemo");
Or 
Student student = (Student) applicationContext.getBean("studentComponent");
@Bean initMethod and destroyMethod attributes
@Bean annotation provides initMethod and destroyMethod attributes to perform certain actions after bean initialization or before bean destruction by a container.
For example, the Student Spring bean has initMethod and destroyMethod attributes:

@Configuration
class AppConfig{

    @Bean(name = "addressBean")
    public Address address(){
        return new Address();
    }

    @Bean(name = "studentBean", initMethod = "init", destroyMethod = "destroy")
    public Student student(){
        return new Student(address());
    }
}
Next, create init() and destroy() methods in Student class:
class Student{
    private Address address;

    public Student(Address address){
        this.address = address;
    }

    public void print(){
        System.out.println("Student class method called ...");
        address.print();
    }

    public void init(){
        System.out.println("Intialization logic");
    }

    public void destroy(){
        System.out.println("Destruction logic");
    }
}
Testing
Run the below code to test all the @Bean annotation use cases:

public class BeanAnnotationDemo {

    public static void main(String[] args) {
        try(var applicationContext = new AnnotationConfigApplicationContext(AppConfig.class)){
            //Student student = applicationContext.getBean(Student.class);
            Student student = (Student) applicationContext.getBean("studentBean");
            String[] beanNames = applicationContext.getBeanDefinitionNames();
            for (String bean: beanNames){
                System.out.println(bean);
            }
            student.print();
        }
    }
}

================================================================================================================================================

2)Spring @Qualifier Annotation Example

Spring @Qualifier Annotation Overview
The @Qualifier annotation is used in conjunction with @Autowired to avoid confusion when we have two or more beans configured for the same type.

If there are multiple implementations for a single interface then we can use @Qualifier to choose the required implementation at runtime.
Spring @Qualifier Annotation Example
Let's take a Message Processing Example - a message can be sent in many ways like Email, SMS, Twitter, etc.
 
Let's create a MessageService interface for multiple message service implementations - EmailService, SMSService, and TwitterService classes.
MessageService interface
public interface MessageService {
    public void sendMsg(String message);
}
Next, let's create implementations - EmailService, SMSService, and TwitterService classes.
EmailService Class
public class EmailService implements MessageService{

    public void sendMsg(String message) {
         System.out.println(message);
    }
}
SMSService Class
public class TwitterService implements MessageService{

    public void sendMsg(String message) {
        System.out.println(message);
    }
}
TwitterService Class

public class SMSService implements MessageService{

    public void sendMsg(String message) {
         System.out.println(message);
    }
}
MessageProcessor Interface and MessageProcessorImpl Class
It's time to see the usage of @Qualifier annotation.
public interface MessageProcessor {
    public void processMsg(String message);
}

public class MessageProcessorImpl implements MessageProcessor {

    private MessageService messageService;

    // setter based DI
    @Autowired
    @Qualifier("twitterService")
    public void setMessageService(MessageService messageService) {
        this.messageService = messageService;
    }
 
    // constructor based DI
    @Autowired
    public MessageProcessorImpl(@Qualifier("twitterService") MessageService messageService) {
        this.messageService = messageService;
    }
 
    public void processMsg(String message) {
        messageService.sendMsg(message);
    }
}
In the above example, Dependency is injected by both setter and constructor so you can use either one of them.

We have used @Qualifier to inject TwitterService bean using constructor injection:
    // setter based DI
    @Autowired
    @Qualifier("twitterService")
    public void setMessageService(MessageService messageService) {
        this.messageService = messageService;
    }
We have used @Qualifier to inject the TwitterService bean using setter injection:
    // constructor based DI
    @Autowired
    public MessageProcessorImpl(@Qualifier("twitterService") MessageService messageService) {
        this.messageService = messageService;
    }
If you want to inject EmailService bean instead of TwitterService bean then you can simply pass bean EmailService bean name. For example:
    // constructor based DI
    @Autowired
    public MessageProcessorImpl(@Qualifier("emailService") MessageService messageService) {
        this.messageService = messageService;
    }
AppConfiguration
Let's write the java based configuration.
@Configuration
@ComponentScan("com.javadevsguide.springframework.di")
public class AppConfiguration {

    @Bean(name="emailService")
    public MessageService emailService(){
         return new EmailService();
    }
 
    @Bean(name="twitterService")
    public MessageService twitterService(){
        return new TwitterService();
    }
 
    @Bean(name="smsService")
    public MessageService smsService(){
        return new SMSService();
    }
 
    @Bean
    public MessageProcessor messageProcessor(){
        return new MessageProcessorImpl(twitterService());
    }
}
Testing
Let's test the example using the Spring IOC container which is an ApplicationContext object.
public class TestApplication {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfiguration.class);
        MessageProcessor processor = applicationContext.getBean(MessageProcessor.class);
        processor.processMsg("twitter message sending ");
    }
}

Output:
twitter message sending 
Conclusion
In this example, we have seen how to use @Qualifier annotation in conjunction with @Autowired to avoid confusion when we have two or more beans configured for the same type.



=============================================================================================================================================================

3) Spring @Autowired Annotation Example

@Autowired Annotation Overview
The @Autowired annotation is used to inject the bean automatically.

The @Autowired annotation is used in Constructor injection, Setter injection, and Field injection.
YouTube Video

Constructor Injection using @Autowired Annotation
Let's create Interfaces and classes required to demonstrate @Autowired annotation.
Pizza Interface
package net.javaguides.springboot.service;

public interface Pizza {
    String getPizza();
}
VegPizza Class
package net.javaguides.springboot.service;

import org.springframework.stereotype.Component;

@Component
public class VegPizza implements Pizza{

    @Override
    public String getPizza() {
        return "Veg Pizza";
    }
}
NonVegPizza
package net.javaguides.springboot.service;

import org.springframework.stereotype.Component;

@Component
public class NonVegPizza implements Pizza{
    @Override
    public String getPizza() {
        return "Non-veg Pizza";
    }
}
PizzaController Class - Constructor Injection using @Autowired Annotation
package net.javaguides.springboot.controller;

import net.javaguides.springboot.service.Pizza;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class PizzaController {

    private Pizza pizza;

    @Autowired
    public PizzaController(@Qualifier("vegPizza") Pizza pizza) {
        System.out.println("inside PizzaController constructor");
        this.pizza = pizza;
    }

    public String getPizza(){
        return pizza.getPizza();
    }
}
In this above code snippet, we are using @Autowired annotation to inject VegPizza dependency in PizzaController class using constructor injection. 
Note that we are using @Qualifier annotation in conjunction with @Autowired to avoid confusion when we have two or more beans configured for the same type.

Constructor injection using @Autowired annotation:
    @Autowired
    public PizzaController(@Qualifier("vegPizza") Pizza pizza) {
        System.out.println("inside PizzaController constructor");
        this.pizza = pizza;
    }
Testing
Let's retrieve the PizzaController spring bean from the ApplicationContext and call its method:
package net.javaguides.springboot;

import net.javaguides.springboot.controller.PizzaController;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.Arrays;

@SpringBootApplication
public class SpringbootDockerDemoApplication {

	public static void main(String[] args) {
		var context = SpringApplication.run(SpringbootDockerDemoApplication.class, args);
		System.out.println("calling pizzaController.getPizza()");
		PizzaController pizzaController = context.getBean(PizzaController.class);
		String message = pizzaController.getPizza();
		System.out.println(message);
	}
}
Output:
calling pizzaController.getPizza()
Veg Pizza
Setter Injection using @Autowired Annotation
Let's use Setter Injection with @Autowired Annotation to inject VegPizza bean in PizzaController class:
package net.javaguides.springboot.controller;

import net.javaguides.springboot.service.Pizza;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class PizzaController {

    private Pizza pizza;

//    @Autowired
//    public PizzaController(@Qualifier("vegPizza") Pizza pizza) {
//        System.out.println("inside PizzaController constructor");
//        this.pizza = pizza;
//    }

    // setter injection
    @Autowired
    @Qualifier("vegPizza")
    public void setPizza(Pizza pizza) {
        this.pizza = pizza;
    }

    public String getPizza(){
        return pizza.getPizza();
    }
}
In this above code snippet, we are using @Autowired annotation to inject VegPizza dependency in PizzaController class using setter injection. Note that we are using @Qualifier annotation in conjunction with @Autowired to avoid confusion when we have two or more beans configured for the same type.

Setter injection using @Autowired annotation:

    @Autowired
    @Qualifier("vegPizza")
    public void setPizza(Pizza pizza) {
        this.pizza = pizza;
    }
Testing
Let's retrieve the PizzaController spring bean from the ApplicationContext and call its method:
package net.javaguides.springboot;

import net.javaguides.springboot.controller.PizzaController;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.Arrays;

@SpringBootApplication
public class SpringbootDockerDemoApplication {

	public static void main(String[] args) {
		var context = SpringApplication.run(SpringbootDockerDemoApplication.class, args);
		System.out.println("calling pizzaController.getPizza()");
		PizzaController pizzaController = context.getBean(PizzaController.class);
		String message = pizzaController.getPizza();
		System.out.println(message);
	}
}
Output:
calling pizzaController.getPizza()
Veg Pizza
Field Injection using @Autowired Annotation
Let's use Field Injection with @Autowired Annotation to inject VegPizza bean in PizzaController class:
package net.javaguides.springboot.controller;

import net.javaguides.springboot.service.Pizza;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class PizzaController {

    @Autowired
    @Qualifier("vegPizza")
    private Pizza pizza;

//    @Autowired
//    public PizzaController(@Qualifier("vegPizza") Pizza pizza) {
//        System.out.println("inside PizzaController constructor");
//        this.pizza = pizza;
//    }

//    // setter injection
//    @Autowired
//    @Qualifier("vegPizza")
//    public void setPizza(Pizza pizza) {
//        this.pizza = pizza;
//    }

    public String getPizza(){
        return pizza.getPizza();
    }
}
In this above code snippet, we are using @Autowired annotation to inject VegPizza dependency in PizzaController class using field injection. Note that we are using @Qualifier annotation in conjunction with @Autowired to avoid confusion when we have two or more beans configured for the same type.

Field injection using @Autowired annotation:

    @Autowired
    @Qualifier("vegPizza")
    private Pizza pizza;
Testing
Let's retrieve the PizzaController spring bean from the ApplicationContext and call its method:
package net.javaguides.springboot;

import net.javaguides.springboot.controller.PizzaController;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.Arrays;

@SpringBootApplication
public class SpringbootDockerDemoApplication {

	public static void main(String[] args) {
		var context = SpringApplication.run(SpringbootDockerDemoApplication.class, args);
		System.out.println("calling pizzaController.getPizza()");
		PizzaController pizzaController = context.getBean(PizzaController.class);
		String message = pizzaController.getPizza();
		System.out.println(message);
	}
}
Output:
calling pizzaController.getPizza()
Veg Pizza



==========================================================================================================================================================

4)Spring @Configuration Annotation with Example

@Configuration Annotation Overview
Spring @Configuration annotation is part of the spring core framework. 
Spring @Configuration annotation indicates that the class has @Bean definition methods. So Spring container can process the class and generate Spring Beans 
to be used in the application.
Calls to @Bean methods on @Configuration classes can also be used to define inter-bean dependencies.
Importing Additional Configuration Classes
You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively,
 you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes.
 
Read more about @Import annotation on Spring @Import Annotation with Example

Refer below diagram shows an internal implementation for your reference:

@Configuration Annotation Example
The simplest possible @Configuration class would read as follows:
import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.companyname.projectname.customer.CustomerService;
import com.companyname.projectname.order.OrderService;

@Configuration
public class Application {

     @Bean
     public CustomerService customerService() {
         return new CustomerService();
     }
 
     @Bean
     public OrderService orderService() {
         return new OrderService();
     }
} 
The AppConfig class above would be equivalent to the following Spring XML:
<beans>
        <bean id="customerService" class="com.companyname.projectname.CustomerService"/>
        <bean id="orderService" class="com.companyname.projectname.OrderService"/>
</beans>
Injecting inter-bean dependencies
When @Bean have dependencies on one another, expressing that dependency is as simple as having one bean method call another:
@Configuration
public class AppConfig {

    @Bean
    public Foo foo() {
        return new Foo(bar());
    }

    @Bean
    public Bar bar() {
        return new Bar();
    }
}
In the example above, the foo bean receives a reference to the bar via constructor injection. 

==========================================================================================================================================================

5)@PropertySource Spring Example


In Spring, you can use @PropertySource annotation to externalize your configuration to a properties file. In this article, we will discuss how to use 
@PropertySource to read a properties file and display the values with @Value and Environment.
The @PropertySource annotation provides a convenient and declarative mechanism for adding a PropertySource to Spring’s Environment. To be used in 
conjunction with @Configuration classes.
Spring @PropertySource Annotation with Simple Example
In this example, we are reading database configuration from file config.properties file and set these property values to DataSourceConfig class using 
Environment.

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;

@Configuration
@PropertySource("classpath:config.properties")
public class ProperySourceDemo implements InitializingBean {

    @Autowired
    Environment env;

    @Override
    public void afterPropertiesSet() throws Exception {
        setDatabaseConfig();
    }

    private void setDatabaseConfig() {
        DataSourceConfig config = new DataSourceConfig();
        config.setDriver(env.getProperty("jdbc.driver"));
        config.setUrl(env.getProperty("jdbc.url"));
        config.setUsername(env.getProperty("jdbc.username"));
        config.setPassword(env.getProperty("jdbc.password"));
        System.out.println(config.toString());
    }
}


Spring @PropertySource Annotation Placeholders Example :

Any ${…} placeholders present in a @PropertySource resource location will be resolved against the set of property sources already registered against the 
environment. 
For example:
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;

@Configuration
@PropertySource("classpath:/com/${my.placeholder:default/path}/config.properties")
public class ProperySourceDemo implements InitializingBean {

    @Autowired
    Environment env;

    @Override
    public void afterPropertiesSet() throws Exception {
        setDatabaseConfig();
    }

    private void setDatabaseConfig() {
       DataSourceConfig config = new DataSourceConfig();
       config.setDriver(env.getProperty("jdbc.driver"));
       config.setUrl(env.getProperty("jdbc.url"));
       config.setUsername(env.getProperty("jdbc.username"));
       config.setPassword(env.getProperty("jdbc.password"));
       System.out.println(config.toString());
    }
}
Assuming that "my.placeholder" is present in one of the property sources already registered, e.g. system properties or environment variables, the placeholder 
will be resolved to the corresponding value. If not, then "default/path" will be used as a default. If no default is specified and a property cannot be 
resolved, an IllegalArgumentException will be thrown
@PropertySources Annotation - Include multiple properties files
Introduces new @PropertySources to support Java 8 and a better way to include multiple properties files.
 @Configuration
 @PropertySources({
  @PropertySource("classpath:config.properties"),
  @PropertySource("classpath:db.properties")
 })
 public class AppConfig {
  //...
 }
Allow @PropertySource to ignore the not found properties file.
 @Configuration
 @PropertySource("classpath:missing.properties")
 public class AppConfig {
  //...
 }
If missing.properties is not found, the system is unable to start and throws FileNotFoundException
 Caused by: java.io.FileNotFoundException: 
  classpath resource [missiong.properties] cannot be opened because it does not exist
In Spring 4, you can use ignoreResourceNotFound to ignore the not found properties file
 @Configuration
 @PropertySource(value="classpath:missing.properties", ignoreResourceNotFound=true)
 public class AppConfig {
  //...
 }

        @PropertySources({
  @PropertySource(value = "classpath:missing.properties", ignoreResourceNotFound=true),
  @PropertySource("classpath:config.properties")
        })
Spring @PropertySource Annotation Complete Example
Let's create a simple Spring boot maven project to bootstrap quickly.
In this example, we are reading database configuration from file config.properties file and set these property values to DataSourceConfig class.
Create a maven project using Spring Initializr at http://start.spring.io/, which is an online Spring Boot application generator.

Create a packing structure as per the above diagram.
Create a config.properties File
Let's create a config.properties file in classpath and we will use @PropertySource annotation to read a properties file and display the values with @Value and Environment.
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/dev_db
jdbc.username=root
jdbc.password=root
Create DataSourceConfig.java File
package net.guides.springboot2.springpropertysourceexample;

public class DataSourceConfig {
 private String driver;
 private String url;
 private String username;
 private String password;
 
 @Override
 public String toString()
 {
  return "DataSourceConfig [driver=" + driver + ", url=" + url + ", username=" + username + "]";
 }
 public String getDriver()
 {
  return driver;
 }
 public void setDriver(String driver)
 {
  this.driver = driver;
 }
 public String getUrl()
 {
  return url;
 }
 public void setUrl(String url)
 {
  this.url = url;
 }
 public String getUsername()
 {
  return username;
 }
 public void setUsername(String username)
 {
  this.username = username;
 }
 public String getPassword()
 {
  return password;
 }
 public void setPassword(String password)
 {
  this.password = password;
 }
}
Create ProperySourceDemo.java File
package net.guides.springboot2.springpropertysourceexample;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;

@Configuration
@PropertySource("classpath:config.properties")
public class ProperySourceDemo implements InitializingBean {

 private static final Logger LOGGER = LoggerFactory.getLogger(ProperySourceDemo.class);

 @Value("${jdbc.driver}")
 private String driver;

 @Value("${jdbc.url}")
 private String url;

 @Value("${jdbc.username}")
 private String username;

 @Value("${jdbc.password}")
 private String password;

 @Autowired
 Environment env;

 @Override
 public void afterPropertiesSet() throws Exception {
  LOGGER.info(driver);
  LOGGER.info(url);
  LOGGER.info(password);
  LOGGER.info(username);
  setDatabaseConfig();
 }

 private void setDatabaseConfig() {
  DataSourceConfig config = new DataSourceConfig();
  config.setDriver(env.getProperty("jdbc.driver"));
  config.setUrl(env.getProperty("jdbc.url"));
  config.setUsername(env.getProperty("jdbc.username"));
  config.setPassword(env.getProperty("jdbc.password"));
  System.out.println(config.toString());
 }
}
The Application.java File
This spring boot application has an entry point Java class called Application.java with the public static void main(String[] args) method, which you can run to
 start the application.
package net.guides.springboot2.springpropertysourceexample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

 public static void main(String[] args) {
  SpringApplication.run(Application.class, args);
 }
}
@SpringBootApplication is a convenience annotation that adds all of the following:
@Configuration tags the class as a source of bean definitions for the application context.
@EnableAutoConfiguration tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.
Normally you would add @EnableWebMvc for a Spring MVC app, but Spring Boot adds it automatically when it sees spring-webmvc on the classpath. This flags the application as a web application and activates key behaviors such as setting up a DispatcherServlet.
@ComponentScan tells Spring to look for other components, configurations, and services in the hello package, allowing it to find the controllers.
Let's run Application.java class and observe the console output.



===========================================================================================================================================================
6) Spring @Import Annotation with Example

@Import Annotation Overview
The @Import annotation indicates one or more @Configuration classes to import.
@Bean definitions declared in imported @Configuration classes should be accessed by using @Autowired injection. Either the bean itself can be autowired, or the configuration class instance declaring the bean can be autowired.
The @Import annotation may be declared at the class level or as a meta-annotation.
Below diagram shows an internal implementation of @Import annotation:


If XML or other non-@Configuration bean definition resources need to be imported, use the @ImportResource annotation instead. For example, if you want to load config.properties file then you can use @ImportResource annotation to load respective property files.
In Spring XML-based configuration we use an <import /> element to load multiple Spring bean configuration files. 
Example:

Spring @Import Annotation Example
Spring provides the alternative @Import annotation which allows for loading @Bean definitions from another configuration class.
@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}
Now, rather than needing to specify both ConfigA class and ConfigB class when instantiating the context, only ConfigB needs to be supplied explicitly:
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
Load Multiple Configuration Class Files Example
@Import annotation also can be used to load @Bean's from multiple configuration class files.
@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}

@Configuration
public class ConfigC {

    @Bean
    public C c() {
        return new C();
    }
}

@Configuration
@Import(value = {ConfigA.class, ConfigB.class, ConfigC.class})
public class ConfigD {

    @Bean
    public D d() {
        return new D();
    }
}



===========================================================================================================================================================
8)Spring @ImportResource Annotation Example


In this article, we will quickly discuss how to use @ImportResource annotation with a simple Spring boot application.


Spring provides a @ImportResource annotation is used to load beans from an applicationContext.xml file into an Application Context.
@ImportResource({"classpath*:applicationContext.xml"})
In this example, we are creating a simple message processing spring boot application. Here we are sending a message using different services like SMSService
, TwitterService, and EmailService. We will configure message service beans in an applicationContext.xml file and we will load beans using 
@ImportResource annotation as:

@SpringBootApplication
@ImportResource({"classpath*:applicationContext.xml"})
public class Springboot2XmlConfigApplication {

 public static void main(String[] args) {
  ApplicationContext applicationContext = SpringApplication.run(Springboot2XmlConfigApplication.class, args);

  MessageProcessor userService = applicationContext.getBean(MessageProcessor.class);
  userService.processMsg("twitter message sending ");
 }
}

While there are multiple ways of doing this, the recommended way is to create a separate configuration class to load this XML bean definition file.

@Configuration
@ImportResource({"classpath*:applicationContext.xml"})
public class XmlConfiguration {
}
The key part of the definition is @ImportResource({" classpath*:applicationContext.xml"}). The applicationContext.xml will be imported from the classpath.
Let's create a complete simple spring boot example to demonstrate how to set up XML based configuration.
Create and Import Spring Boot application
Let's quickly create a Spring Boot application using Spring Initializr at http://start.spring.io/, which is an online Spring Boot application generator.
Please refer the project structure as in below diagram.

The pom.xml File
Let's create Message POJO class with few service class for demonstration. In this example, we are sending messages using different services like SMSService,
 TwitterService, and EmailService.
Message.java

package net.guides.springboot2.springboot2xmlconfig.model;

public class Message {
 private int id;
 private String message;
 public Message(int id, String message) {
  super();
  this.id = id;
  this.message = message;
 }
}
MessageService.java
public interface MessageService {
 public void sendMsg(String message);
}
EmailService.java
import org.springframework.stereotype.Service;

public class EmailService implements MessageService{

 public void sendMsg(String message) {
  System.out.println(message);
 }

}
SMSService.java
import org.springframework.stereotype.Service;

public class SMSService implements MessageService{

 public void sendMsg(String message) {
  System.out.println(message);
 }

}
TwitterService.java
import org.springframework.stereotype.Service;

public class TwitterService implements MessageService{

 public void sendMsg(String message) {
  System.out.println(message);
 }

}
MessageProcessor.java
public interface MessageProcessor {
 public void processMsg(String message);
}

MessageProcessorImpl.java
package net.guides.springboot2.springboot2xmlconfig.service;

public class MessageProcessorImpl implements MessageProcessor {

 private MessageService messageService;

 public void setMessageService(MessageService messageService) {
  this.messageService = messageService;
 }

 public void processMsg(String message) {
  messageService.sendMsg(message);
 }
}

The applicationContext.xml File
Let's create and configure Spring beans in applicationContext.xml file.
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns:context="http://www.springframework.org/schema/context"
 xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

 <bean id="emailService"
  class="net.guides.springboot2.springboot2xmlconfig.service.EmailService" />
 <bean id="sMSService"
  class="net.guides.springboot2.springboot2xmlconfig.service.SMSService" />
 <bean id="twitterService"
  class="net.guides.springboot2.springboot2xmlconfig.service.TwitterService" />
 <bean id="messageProcessor"
  class="net.guides.springboot2.springboot2xmlconfig.service.MessageProcessorImpl">
  <property name="messageService" ref="twitterService"></property>
 </bean>

</beans>

Running Application:

This spring boot application has an entry point Java class called Springboot2XmlConfigApplication.java with the 
public static void main(String[] args) method, which you can run to start the application.

package net.guides.springboot2.springboot2xmlconfig;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ImportResource;

import net.guides.springboot2.springboot2xmlconfig.service.MessageProcessor;

@SpringBootApplication
@ImportResource({"classpath*:applicationContext.xml"})
public class Springboot2XmlConfigApplication {

 public static void main(String[] args) {
  ApplicationContext applicationContext = SpringApplication.run(Springboot2XmlConfigApplication.class, args);

  MessageProcessor userService = applicationContext.getBean(MessageProcessor.class);
  userService.processMsg("twitter message sending ");
 }
}
==========================================================================================================================================================

9) Spring @Lazy Annotation Example

By default, the Spring IoC container creates and initializes all singleton beans at the time of application startup. We can prevent this pre-initialization of a singleton bean by using the @Lazy annotation.
 
The @Lazy annotation may be used on any class directly or indirectly annotated with @Component or on methods annotated with @Bean. 

In this example, we will use a Java-based configuration(using @Configuration and @Bean). 
Spring @Lazy Annotation Example
Let's create an example to demonstrate using @Lazy annotation in a spring application.
Create a Simple Maven Project
Create a simple maven project using your favorite IDE and refer below section for packaging structure. If you are new to maven, read the article How to Create a Simple Maven Project.
Project Structure
The below diagram shows a project structure for your reference -

Maven Dependency
Note that Spring framework 6 required Java 17 or later version:
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>learn-spring-framework</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-core -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>6.0.4</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>6.0.4</version>
        </dependency>

    </dependencies>
</project>
Create Spring Beans - FirstBean and SecondBean
FirstBean.java
package net.javaguides.spring.lazy;

public class FirstBean {

    public FirstBean() {
        System.out.println("Inside FirstBean Constuctor");
    }

    public void test() {
        System.out.println("Method of FirstBean Class");
    }
}
SecondBean.java
package net.javaguides.spring.lazy;

public class SecondBean {

    public SecondBean() {
        System.out.println("Inside SecondBean Constuctor");
    }

    public void test() {
        System.out.println("Method of SecondBean Class");
    }
}
Java-Based Configuration - AppConfig.java
Declare the above beans in java based configuration class.
package net.javaguides.spring.lazy;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;

@Configuration
public class AppConfig {

    @Lazy(value = true)
    @Bean
    public FirstBean firstBean() {
        return new FirstBean();
    }

    @Bean
    public SecondBean secondBean() {
        return new SecondBean();
    }
}
Running Spring Application - Application.java
Let's create a main class and run an application.
package net.javaguides.spring.lazy;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Application {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        FirstBean firstBean = context.getBean(FirstBean.class);
        firstBean.test();
        context.close();
    }
}
Output:
Inside SecondBean Constuctor
Inside FirstBean Constuctor
Method of FirstBean Class
As we can see, bean secondBean is initialized by the Spring container while bean firstBean is initialized explicitly.

====================================================================================================================================================

10)Spring @Primary Annotation Example

Let's create an example to demonstrate the usage of use @Primary annotation in a spring application.
Create a Simple Maven Project
Create a simple maven project using your favorite IDE and refer below section for packaging structure. If you are new to maven then read this article How to Create a Simple Maven Project.
Project Structure
The below diagram shows a project structure for your reference -

The pom.xml File
DataSource.java
Let's create a DataSource interface and the below content to it:
package com.spring.core.assignment;

public interface DataSource {
    String[] getEmails();
}
MySQLDataSource.java
Let's create MySQLDataSource class that implements the DataSource interface and its method:
package com.spring.core.assignment;

import org.springframework.stereotype.Component;

@Component
public class MySQLDataSource implements DataSource{

    @Override
    public String[] getEmails() {

        String[] emails = {"ramesh@gmail.com", "tony@gmail.com", "john@gmail.com"};

        return emails;
    }
}
PosgreSQLDataSource.java
Let's create PostgreSQLDataSource class that implements the DataSource interface and its method:
package com.spring.core.assignment;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;

@Component
@Primary
public class PostgreSQLDataSource implements DataSource{

    @Override
    public String[] getEmails() {

        String[] emails = {"ramesh@gmail.com", "tony@gmail.com", "john@gmail.com"};

        return emails;
    }
}
Note that this class is annotated with @Primary annotation and it tells Spring Container to give higher preference to this class while injecting using @Autowired annotation.
EmailService.java
Next, let's create EmailService class and inject the PostgreSQLDataSource bean as a dependency:
package com.spring.core.assignment;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class EmailService {

    private DataSource dataSource;

    @Autowired
    public EmailService(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    void sendEmail(){
        String[] emails = dataSource.getEmails();

        for(String email: emails){
            System.out.println(email);
        }
    }
}
Note that we have annotated PostgreSQLDataSource class with@Primary annotation and so Spring Container injects PostgreSQLDataSource class as spring bean.
Annotation-Based Configuration - AppConfig.java
package com.spring.core.assignment;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.spring.core.assignment")
public class AppConfig {
}
Running Spring Application - Application.java
Let's create a main class and run an application.
package com.spring.core.assignment;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Client {

    public static void main(String[] args) {

        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);

        EmailService emailService = applicationContext.getBean(EmailService.class);

        emailService.sendEmail();
    }
}
Output:
ramesh@gmail.com
tony@gmail.com
john@gmail.com

=====================================================================================================================================================


11) Spring @Repository Overview  


DAO or Repository classes usually represent the database access layer in an application and should be annotated with @Repository annotation.

As of Spring 2.5, this annotation also serves as a specialization of @Component, allowing for implementation classes to be autodetected through classpath scanning.
 
@Repository annotation internally annotated with @Component annotation as shown in the below diagram:

Whenever we annotated a class with @Repository annotation then Spring Container will automatically create a Spring bean for that class.
@Repository Annotation Example
Let's create a simple Spring boot application to bootstrap quickly. Add the below dependencies to your pom.xml file.
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
Create User JPA Entity
Let's create a simple User JPA entity that maps with the users table in the database:
@Entity
@Table(name = "users")
class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    private String name;

    public User(int id, String name) {
        super();
        this.id = id;
        this.name = name;
    }

    public User() {}

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
Create UserRepository :

Next, create a UserRepository interface and annotate with @Repository annotation:

@Repository
interface UserRepository extends JpaRepository < User, Integer > {

}

Note Spring Data JPA automatically provides an implementation for the above interface.
Create UserService and UserServiceImpl
interface UserService {
    public void saveUser(User user);
}

@Service
class UserServiceImpl implements UserService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public void saveUser(User user) {
        userRepository.save(user);
    }
}
Testing
Let's write a code to test UserRepository to save user objects into database table:
@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext applicationContext = SpringApplication.run(DemoApplication.class, args);
        UserService userService = (UserService) applicationContext.getBean("userServiceImpl");
        userService.saveUser(new User(10, "Ramesh"));
    }
}



======================================================================================================================================

12)Spring @Service Annotation Overview
The business logic of an application usually resides within the service layer – so we’ll use the @Service annotation to indicate that a class belongs to the service layer.

Well, @Service annotation serves as a specialization of @Component, allowing for implementation classes to be autodetected through classpath scanning.
 
The below diagram shows a source code definition of @Service annotation. Spring context will autodetect these classes when annotation-based configuration and classpath scanning is used because it is a specialization of @Component as shown below diagram.


Whenever we annotated a class with @Service annotation then Spring Container will automatically create a Spring bean for that class.
Spring @Service Annotation Example
Let's create a simple Spring boot application to bootstrap quickly. Add the below dependencies to your pom.xml file.
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
Create User JPA Entity
Let's create a simple User JPA entity that maps with the users table in the database:
@Entity
@Table(name = "users")
class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    private String name;

    public User(int id, String name) {
        super();
        this.id = id;
        this.name = name;
    }

    public User() {}

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
Create UserRepository
Next, create a UserRepository interface and annotate with @Repository annotation:
@Repository
interface UserRepository extends JpaRepository < User, Integer > {

}
Note Spring Data JPA automatically provides an implementation for the above interface.
Create UserService and UserServiceImpl
interface UserService {
    public void saveUser(User user);
}

@Service
class UserServiceImpl implements UserService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public void saveUser(User user) {
        userRepository.save(user);
    }
}
Testing
Let's write a code to test UserRepository to save user objects into the database table:
@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext applicationContext = SpringApplication.run(DemoApplication.class, args);
        UserService userService = (UserService) applicationContext.getBean("userServiceImpl");
        userService.saveUser(new User(10, "Ramesh"));
    }
}


===================================================================================================================================
13)The Spring @Controller and @RestController Annotations

In this quick article, we’ll discuss the difference between @Controller and @RestController annotations in Spring MVC.

The first annotation is used for traditional Spring controllers and has been part of the framework for a very long time.  The @RestController annotation was introduced in Spring 4.0 to simplify the creation of RESTful web services. It’s a convenience annotation that combines @Controller and @ResponseBody – which eliminates the need to annotate every request handling method of the controller class with the @ResponseBody annotation.

The key difference between a traditional Spring MVC controller and the RESTful web service controller is the way the HTTP response body is created. While the traditional MVC controller relies on the View technology, the RESTful web service controller simply returns the object and the object data is written directly to the HTTP response as JSON/XML.
@Controller Annotation
Classic controllers can be annotated with the @Controller annotation. This is simply a specialization of the @Component class and allows implementation classes to be autodetected through classpath scanning.

In order to develop REST web services using Spring MVC @Controller, we need to add a @ResponseBody annotation to each of the @RequestMapping methods in the return value as shown in the below diagram. 


@Controller Annotation Example
@Controller is typically used in combination with a @RequestMapping annotation used on request handling methods.

Notice that in the below example, we added @ResponseBody annotation to each of the @RequestMapping methods in the return value. 
@Controller
@RequestMapping("/api/v1")
public class EmployeeController {
    @Autowired
    private EmployeeRepository employeeRepository;

    @GetMapping("/employees")
    public @ResponseBody List<Employee> getAllEmployees() {
        return employeeRepository.findAll();
    }

    @GetMapping("/employees/{id}")
    public @ResponseBody ResponseEntity<Employee> getEmployeeById(@PathVariable(value = "id") Long employeeId)
        throws ResourceNotFoundException {
        Employee employee = employeeRepository.findById(employeeId)
          .orElseThrow(() -> new ResourceNotFoundException("Employee not found for this id :: " + employeeId));
        return ResponseEntity.ok().body(employee);
    }
    
    @PostMapping("/employees")
    public @ResponseBody Employee createEmployee(@Valid @RequestBody Employee employee) {
        return employeeRepository.save(employee);
    }

    @PutMapping("/employees/{id}")
    public @ResponseBody ResponseEntity<Employee> updateEmployee(@PathVariable(value = "id") Long employeeId,
         @Valid @RequestBody Employee employeeDetails) throws ResourceNotFoundException {
        Employee employee = employeeRepository.findById(employeeId)
        .orElseThrow(() -> new ResourceNotFoundException("Employee not found for this id :: " + employeeId));

        employee.setEmailId(employeeDetails.getEmailId());
        employee.setLastName(employeeDetails.getLastName());
        employee.setFirstName(employeeDetails.getFirstName());
        final Employee updatedEmployee = employeeRepository.save(employee);
        return ResponseEntity.ok(updatedEmployee);
    }

    @DeleteMapping("/employees/{id}")
    public @ResponseBody Map<String, Boolean> deleteEmployee(@PathVariable(value = "id") Long employeeId)
         throws ResourceNotFoundException {
        Employee employee = employeeRepository.findById(employeeId)
       .orElseThrow(() -> new ResourceNotFoundException("Employee not found for this id :: " + employeeId));

        employeeRepository.delete(employee);
        Map<String, Boolean> response = new HashMap<>();
        response.put("deleted", Boolean.TRUE);
        return response;
    }
}
@RestController Annotation
Spring 4.0 introduced @RestController, a specialized version of the controller which is a convenience annotation that does nothing more than adding the @Controller and @ResponseBody annotations. 

By annotating the controller class with @RestController annotation, you no longer need to add @ResponseBody to all the request mapping methods. The @ResponseBody annotation is active by default.



@RestController Annotation Example
To use @RestController in our example, all we need to do is modify the @Controller to @RestController and remove the @ResponseBody from each method. The resultant class should look like the following:
@RestController
@RequestMapping("/api/v1")
public class EmployeeController {
    @Autowired
    private EmployeeRepository employeeRepository;

    @GetMapping("/employees")
    public List<Employee> getAllEmployees() {
        return employeeRepository.findAll();
    }

    @GetMapping("/employees/{id}")
    public ResponseEntity<Employee> getEmployeeById(@PathVariable(value = "id") Long employeeId)
        throws ResourceNotFoundException {
        Employee employee = employeeRepository.findById(employeeId)
          .orElseThrow(() -> new ResourceNotFoundException("Employee not found for this id :: " + employeeId));
        return ResponseEntity.ok().body(employee);
    }
    
    @PostMapping("/employees")
    public Employee createEmployee(@Valid @RequestBody Employee employee) {
        return employeeRepository.save(employee);
    }

    @PutMapping("/employees/{id}")
    public ResponseEntity<Employee> updateEmployee(@PathVariable(value = "id") Long employeeId,
         @Valid @RequestBody Employee employeeDetails) throws ResourceNotFoundException {
        Employee employee = employeeRepository.findById(employeeId)
        .orElseThrow(() -> new ResourceNotFoundException("Employee not found for this id :: " + employeeId));

        employee.setEmailId(employeeDetails.getEmailId());
        employee.setLastName(employeeDetails.getLastName());
        employee.setFirstName(employeeDetails.getFirstName());
        final Employee updatedEmployee = employeeRepository.save(employee);
        return ResponseEntity.ok(updatedEmployee);
    }

    @DeleteMapping("/employees/{id}")
    public Map<String, Boolean> deleteEmployee(@PathVariable(value = "id") Long employeeId)
         throws ResourceNotFoundException {
        Employee employee = employeeRepository.findById(employeeId)
       .orElseThrow(() -> new ResourceNotFoundException("Employee not found for this id :: " + employeeId));

        employeeRepository.delete(employee);
        Map<String, Boolean> response = new HashMap<>();
        response.put("deleted", Boolean.TRUE);
        return response;
    }
}
You can find a complete example using Spring MVC @RestController annotation at Spring Boot 2 JPA MySQL CRUD Example
The controller is annotated with the @RestController annotation, therefore the @ResponseBody isn’t required.

Every request handling method of the controller class automatically serializes return objects into HttpResponse.


@Controller

@RestController

@Controller is used to mark classes as Spring MVC Controller.	@RestController annotation is a special controller used in RESTful Web services, and it’s the combination of @Controller and @ResponseBody annotation.
It is a specialized version of @Component annotation.	It is a specialized version of @Controller annotation.
In @Controller, we can return a view in Spring Web MVC.	In @RestController, we can not return a view.
@Controller annotation indicates that the class is a “controller” like a web controller.	@RestController annotation indicates that class is a controller where @RequestMapping methods assume @ResponseBody semantics by default.
In @Controller, we need to use @ResponseBody on every handler method.	In @RestController, we don’t need to use @ResponseBody on every handler method.
It was added to Spring 2.5 version.	It was added to Spring 4.0 version.


==================================================================================================================================================

15)Spring @Scope Annotation with Prototype Scope Example

We use @Scope to define the scope of a @Component class or a @Bean definition.

The @Scope annotation can use with all Spring bean scopes:
Singleton: only one instance of the bean is created and shared across the entire application. This is the default scope.

Prototype: a new instance of the bean is created every time it is requested.

Request: a new instance of the bean is created for each HTTP request. It is only applicable to web applications.

Session: a new instance of the bean is created for each HTTP session. It is only applicable to web applications.

Application: a single instance of the bean is created and shared across the entire application context. It is only applicable to web applications.

In this article, we will discuss how to use @Scope annotation with Prototype scope with an example.
When a spring bean is scoped as a prototype, the Spring IoC container creates a new bean instance every time when a request is made for that bean.
We can define the scope of a bean as a prototype using the scope="prototype" attribute of the element or using @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) annotation.
We will demonstrate this example using Annotation based (@Component) as well as Java-based configuration(@Bean).
Spring @Scope Annotation + Prototype Scope + @Component Example
Let's create an example to demonstrate the usage of use @Scope annotation with a prototype scope in a spring application.
Create a Simple Maven Project
Create a simple maven project using your favorite IDE and refer below section for packaging structure. If you are new to maven then read this article How to Create a Simple Maven Project.
Project Structure

Create MessageService interface as follows.
MessageService.java
package net.javaguides.spring.scope;

public interface MessageService {

    String getMessage();

    void setMessage(String message);
}
Let's create TwitterMessageService class which implements the MessageService interface.
TwitterMessageService.java
package net.javaguides.spring.scope;

import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class TwitterMessageService implements MessageService {

    private String message;

    @Override
    public String getMessage() {
        return message;
    }

    @Override
    public void setMessage(String message) {
        this.message = message;
    }
}
Annotation-Based Configuration - AppConfig.java
package net.javaguides.spring.scope;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "net.javaguides.spring")
public class AppConfig {
 
}
@ComponentScan annotation scans all beans whose class is annotated by the @Component annotation in a package specified by basePackages attribute.
Running Spring Application - Application.java
Let's create a main class and run an application.
package net.javaguides.spring.scope;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Application {
    public static void main(String[] args) {
         AnnotationConfigApplicationContext  context = new AnnotationConfigApplicationContext(AppConfig.class);
         MessageService messageService = context.getBean(MessageService.class);
         messageService.setMessage("TwitterMessageService Implementation");
         System.out.println(messageService.getMessage());
  
         MessageService messageService1 = context.getBean(MessageService.class);
         System.out.println(messageService1.getMessage());
         context.close();
    }
}
Output
TwitterMessageService Implementation
null
Let's develop the same example using Java-based configuration with @Bean annotation.
Spring @Scope Annotation + Prototype Scope + @Bean Example
Create MessageService interface as follows.
MessageService.java
package net.javaguides.spring.scope;

public interface MessageService {

    String getMessage();

    void setMessage(String message);
}
Let's create TwitterMessageService class which implements the MessageService interface.
TwitterMessageService.java
package net.javaguides.spring.scope;

import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

public class TwitterMessageService implements MessageService {

    private String message;

    @Override
    public String getMessage() {
        return message;
    }

    @Override
    public void setMessage(String message) {
        this.message = message;
    }
}
Java-based Configuration - AppConfig.java
Declare the above beans in java based configuration class.
package net.javaguides.spring.scope;

import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

@Configuration
public class AppConfig {

    @Bean
    @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
    public MessageService messageService() {
        return new TwitterMessageService();
    }
}
Running Spring Application - Application.java
Let's create a main class and run an application.
package net.javaguides.spring.scope;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Application {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext  context = new AnnotationConfigApplicationContext(AppConfig.class);
        MessageService messageService = context.getBean(MessageService.class);
        messageService.setMessage("TwitterMessageService Implementation");
        System.out.println(messageService.getMessage());
  
        MessageService messageService1 = context.getBean(MessageService.class);
        System.out.println(messageService1.getMessage());
        context.close();
    }
}
Output
TwitterMessageService Implementation
null

=>Spring @Scope annotation with Singleton Scope Example

In this article, we will discuss how to create a bean, scoped as a singleton, using the @Scope annotation.

We use @Scope to define the scope of a @Component class or a @Bean definition.

When a Spring bean is scoped as a singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition.
 
By default, the Spring IoC container creates and initializes all beans as a singleton. But we can define the scope of a bean as a singleton using the scope="singleton" attribute of the element or using the @Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON) annotation.
 
We will demonstrate this example using Annotation based (@Component) as well as Java-based configuration(@Bean). 
Spring @Scope Annotation + Singleton Scope + @Component Example
Let's create an example to demonstrate the usage of use @Scope annotation with a singleton scope in a spring application. 
Create a Simple Maven Project
Create a simple maven project using your favorite IDE and refer below section for packaging structure. If you are new to maven then read this article How to Create a Simple Maven Project.
Project Structure
MessageService.java
Next, let's create a MessageService interface as follows.
package net.javaguides.spring.scope;

public interface MessageService {

    String getMessage();

    void setMessage(String message);
}
Let's create TwitterMessageService class which implements the MessageService interface.
TwitterMessageService.java
package net.javaguides.spring.scope;

import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)
public class TwitterMessageService implements MessageService {

    private String message;

    @Override
    public String getMessage() {
        return message;
    }

    @Override
    public void setMessage(String message) {
        this.message = message;
    }
}
Annotation-Based Configuration - AppConfig.java
package net.javaguides.spring.scope;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "net.javaguides.spring")
public class AppConfig {
 
}
@ComponentScan annotation scans all beans whose class is annotated by the @Component annotation in a package specified by basePackages attribute. 
Running Spring Application - Application.java
Let's create a main class and run an application.
package net.javaguides.spring.scope;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Application {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext  context = new AnnotationConfigApplicationContext(AppConfig.class);
        MessageService messageService = context.getBean(MessageService.class);
        messageService.setMessage("TwitterMessageService Implementation");
        System.out.println(messageService.getMessage());
  
        MessageService messageService1 = context.getBean(MessageService.class);
        System.out.println(messageService1.getMessage());
        context.close();
    }
}
Output
TwitterMessageService Implementation
TwitterMessageService Implementation

========================================================================================================================================================

================================================================================================================================================

14)