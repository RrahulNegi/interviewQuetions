1. What are the features of Spring Framework?

Spring framework follows layered architecture pattern that helps in the necessary components selection along with providing a robust and cohesive framework for J2EE applications development.
The AOP (Aspect Oriented Programming) part of Spring supports unified development by ensuring separation of application’s business logic from other system services.
Spring provides highly configurable MVC web application framework which has the ability to switch to other frameworks easily.
Provides provision of creation and management of the configurations and defining the lifecycle of application objects.
Spring has a special design principle which is known as IoC (Inversion of Control) that supports objects to give their dependencies rather than looking for creating dependent objects.
Spring is a lightweight, java based, loosely coupled framework.
Spring provides generic abstraction layer for transaction management that is also very useful for container-less environments.
Spring provides a convenient API to translate technology-specific exceptions (thrown by JDBC, Hibernate or other frameworks) into consistent, unchecked exceptions. This introduces abstraction and greatly simplifies exception handling.


2. What is a Spring configuration file?
A Spring configuration file is basically an XML file that mainly contains the classes information and describes how those classes are configured and linked to each other. 
The XML configuration files are verbose and cleaner.

3. What do you mean by IoC (Inversion of Control) Container?
Spring container forms the core of the Spring Framework. The Spring container uses Dependency Injection (DI) for managing the 
application components by creating objects, wiring them together along with configuring and managing their overall life cycles. The instructions for the spring container to do the tasks can be provided either by XML configuration, Java annotations, or Java code.

4. What do you understand by Dependency Injection?
The main idea in Dependency Injection is that you don’t have to create your objects but you just have to describe how they 
should be created.

The components and services need not be connected by us in the code directly. We have to describe which services are needed by which components in the configuration file. The IoC container present in Spring will wire them up together.

In Java, the 2 major ways of achieving dependency injection are:

Constructor injection: Here, the IoC container invokes the class constructor with a number of arguments where each argument 
represents a dependency on the other class.

Setter injection: Here, the spring container calls the setter methods on the beans after invoking a no-argument static factory 
method or default constructor to instantiate the bean.

5. Explain the difference between constructor and setter injection?

Partial dependency: can be injected using setter injection but it is not possible by constructor. Suppose there are 3 properties in a class, having 3 arg constructor and setters methods. In such case, if you want to pass information for only one property, it is possible by setter method only.
Overriding: Setter injection overrides the constructor injection. If we use both constructor and setter injection, IOC container will use the setter injection.
Changes: We can easily change the value by setter injection. It doesn't create a new bean instance always like constructor. So setter injection is flexible than constructor injection.

6. What are Spring Beans?
They are the objects forming the backbone of the user’s application and are managed by the Spring IoC container.
Spring beans are instantiated, configured, wired, and managed by IoC container.
Beans are created with the configuration metadata that the users supply to the container (by means of XML or java annotations configurations.)

7. How is the configuration meta data provided to the spring container?
There are 3 ways of providing the configuration metadata. They are as follows:

XML-Based configuration: The bean configurations and their dependencies are specified in XML configuration files. 
This starts with a bean tag as shown below:
   <bean id="interviewBitBean" class="org.intervuewBit.firstSpring.InterviewBitBean">
    <property name="name" value="InterviewBit"></property>
   </bean>

   
Annotation-Based configuration: Instead of the XML approach, the beans can be configured into the component class itself by using annotations on the relevant class, method, or field declaration.
Annotation wiring is not active in the Spring container by default. This has to be enabled in the Spring XML configuration file as shown below
<beans>
<context:annotation-config/>
<!-- bean definitions go here -->
</beans>

Java-based configuration: Spring Framework introduced key features as part of new Java configuration support. 
This makes use of the @Configuration annotated classes and @Bean annotated methods. Note that:
@Bean annotation has the same role as the <bean/> element.
Classes annotated with @Configuration allow to define inter-bean dependencies by simply calling other @Bean methods in the 
same class

8. What are the bean scopes available in Spring?

Singleton: The scope of bean definition while using this would be a single instance per IoC container.
Prototype: Here, the scope for a single bean definition can be any number of object instances.
Request: The scope of the bean definition is an HTTP request.
Session: Here, the scope of the bean definition is HTTP-session.
Global-session: The scope of the bean definition here is a Global HTTP session

9.  Explain Bean life cycle in Spring Bean Factory Container.
The Bean life cycle is as follows:

The IoC container instantiates the bean from the bean’s definition in the XML file.
Spring then populates all of the properties using the dependency injection as specified in the bean definition.
The bean factory container calls setBeanName() which take the bean ID and the corresponding bean has to implement BeanNameAware interface.
The factory then calls setBeanFactory() by passing an instance of itself (if BeanFactoryAware interface is implemented in the bean).
If BeanPostProcessors is associated with a bean, then the preProcessBeforeInitialization() methods are invoked.
If an init-method is specified, then it will be called.
Lastly, postProcessAfterInitialization() methods will be called if there are any BeanPostProcessors associated with the bean that needs to be run post creation.


10. What do you understand by Bean Wiring.
When beans are combined together within the Spring container, they are said to be wired or the phenomenon is called bean wiring.
The Spring container should know what beans are needed and how the beans are dependent on each other while wiring beans. This is given by means of XML / Annotations / Java code-based configuration.
12. What is autowiring and name the different modes of it?
The IoC container autowires relationships between the application beans. Spring lets collaborators resolve which bean has to be wired automatically by inspecting the contents of the BeanFactory.
Different modes of this process are:

no: This means no autowiring and is the default setting. An explicit bean reference should be used for wiring.
byName: The bean dependency is injected according to the name of the bean. This matches and wires its properties with the beans defined by the same names as per the configuration.
byType: This injects the bean dependency based on type.
constructor: Here, it injects the bean dependency by calling the constructor of the class. It has a large number of parameters.
autodetect: First the container tries to wire using autowire by the constructor, if it isn't possible then it tries to autowire by byType

11. What are the limitations of autowiring?
Overriding possibility: Dependencies are specified using <constructor-arg> and <property>  settings that override autowiring.
Data types restriction: Primitive data types, Strings, and Classes can’t be autowired.

12. Spring FactoryBean Example

A factory bean is a bean that serves as a factory for creating other beans within the IoC container. Conceptually, a 
factory bean is very similar to a factory method, but it is a Spring-specific bean that can be identified by the Spring 
IoC container during bean construction and can be used by container to instantiate other beans.

Creating beans using FactoryBean:

To create a factory bean, all you have to do is to implement the FactoryBean interface by your creator bean class which 
will be creating actual other beans. Or to keep it simple, you can extend AbstractFactoryBean class.

By extending the AbstractFactoryBean class, your factory bean can simply override the createInstance() method to create the target bean instance. In addition, you have to return the target bean’s type in the getObjectType() method for the auto-wiring feature to work properly.

EmployeeFactoryBean.java
public class EmployeeFactoryBean extends AbstractFactoryBean<Object>
{
    /This method will be called by container to create new instances
    @Override
    protected Object createInstance() throws Exception
    {
        //code
    }
 
    //This method is required for autowiring to work correctly
    @Override
    public Class<EmployeeDTO> getObjectType() {
        return EmployeeDTO.class;
    }
}



Why use factory beans?

Factory beans are mostly used to implement framework facilities. Here are some examples:

When looking up an object (such as a data source) from JNDI, you can use JndiObjectFactoryBean.
When using classic Spring AOP to create a proxy for a bean, you can use ProxyFactoryBean.
When creating a Hibernate session factory in the IoC container, you can use LocalSessionFactoryBean.
In most cases, you rarely have to write any custom factory beans, because they are framework-specific and cannot be used 
outside the scope of the Spring IoC container.

FactoryBean Demo

In this example, I am creating a factory bean to instantiate different types of Employee objects e.g. their manager, 
director etc. with some pre-populated attributes.

Our EmployeeDTO class looks like this.


EmployeeDTO.java
package com.howtodoinjava.demo.model;
 
public class EmployeeDTO {
 
  private Integer id;
  private String firstName;
  private String lastName;
  private String designation;
 
  //Setters and Getters are hidden behind this comment.
 
  @Override
  public String toString() {
    return "Employee [id=" + id + ", firstName=" + firstName
        + ", lastName=" + lastName + ", type=" + designation + "]";
  }
}

EmployeeFactoryBean class extends AbstractFactoryBean class and implements it’s two methods createInstance() and getObjectType().

EmployeeFactoryBean.java
import org.springframework.beans.factory.config.AbstractFactoryBean;
 
import com.howtodoinjava.demo.model.EmployeeDTO;
 
public class EmployeeFactoryBean extends AbstractFactoryBean<Object> 
{
  private String designation;
   
  public String getDesignation() {
    return designation;
  }
 
  public void setDesignation(String designation) {
    this.designation = designation;
  }
 
  //This method will be called by container to create new instances
  @Override
  protected Object createInstance() throws Exception 
  {
    EmployeeDTO employee = new EmployeeDTO();
    employee.setId(-1);
    employee.setFirstName("dummy");
    employee.setLastName("dummy");
    //Set designation here
    employee.setDesignation(designation);
    return employee;
  }
 
  //This method is required for autowiring to work correctly
  @Override
  public Class<EmployeeDTO> getObjectType() {
    return EmployeeDTO.class;
  }
}
You will define various Employee types in context file as below.

applicationContext.xml
<bean id="manager"  class="com.howtodoinjava.demo.factory.EmployeeFactoryBean">
  <property name="designation" value="Manager" />
</bean>
 
<bean id="director"  class="com.howtodoinjava.demo.factory.EmployeeFactoryBean">
  <property name="designation" value="Director" />
</bean>
To test above factory beans, use below code:

TestSpringContext.java
public class TestSpringContext 
{
  @SuppressWarnings("resource")
  public static void main(String[] args) 
  {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
 
    EmployeeDTO manager = (EmployeeDTO) context.getBean("manager");
    System.out.println(manager);
     
    EmployeeDTO director = (EmployeeDTO) context.getBean("director");
    System.out.println(director);
  }
}
 
Output:
 
Employee [id=-1, firstName=dummy, lastName=dummy, type=Manager]
Employee [id=-1, firstName=dummy, lastName=dummy, type=Director]
As you can see that EmployeeFactoryBean created two different employee objects using same factory method.

13. Spring static factory-method example

In Spring framework, if you want to create a bean by invoking a static factory-method, whose purpose is to encapsulate the 
object-creation process in a static method then you could use factory-method attribute


Static factory method example
If you want to create different EmployeeDTO objects based on it’s designation using a static factory method, you can do it like below example.

EmployeeDTO.java
public class EmployeeDTO {
 
    private Integer id;
    private String firstName;
    private String lastName;
 
    private String designation;
 
    //Setters and Getters
 
    @Override
    public String toString() {
        return "Employee [id=" + id + ", firstName=" + firstName
                + ", lastName=" + lastName + ", type=" + designation + "]";
    }
}
Create static factory method.

EmployeeFactory.java
public class EmployeeFactory {
     
    public static EmployeeDTO createEmployeeOfType(String type) 
    {
        if ("manager".equals(type) || "director".equals(type)) 
        {
            EmployeeDTO employee = new EmployeeDTO();
             
            employee.setId(-1);
            employee.setFirstName("dummy");
            employee.setLastName("dummy");
            //Set designation here
            employee.setDesignation(type);
             
            return employee;
        }
        else
        {
            throw new IllegalArgumentException("Unknown product");
        }
    }
}
Use factory-method attribute for creating the beans.

applicationContext.xml
<bean id="manager" class="com.howtodoinjava.demo.factory.EmployeeFactory"
    factory-method="createEmployeeOfType">
    <constructor-arg value="manager" />
</bean>
 
<bean id="director" class="com.howtodoinjava.demo.factory.EmployeeFactory"
    factory-method="createEmployeeOfType">
    <constructor-arg value="director" />
</bean>
Demo
Let’s test above static factory-method configuration.

TestSpringStaticFactoryMethod.java
public class TestSpringStaticFactoryMethod 
{
    @SuppressWarnings("resource")
    public static void main(String[] args) throws Exception 
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
 
        EmployeeDTO manager = (EmployeeDTO) context.getBean("manager");
        System.out.println(manager);
         
        EmployeeDTO director = (EmployeeDTO) context.getBean("director");
        System.out.println(director);
    }
}
Watch the output in console.

Console
Employee [id=-1, firstName=dummy, lastName=dummy, type=manager]
Employee [id=-1, firstName=dummy, lastName=dummy, type=director]



15. Spring ResourceLoaderAware – Read file in Spring


Learn different ways to load resources or files (e.g. text files, XML files, properties file, or image files) into the Spring application context. Spring ResourceLoader provides a unified getResource() method for us to retrieve an external resource by a resource path.

1. Resource interface represents a resource
Resource is a general interface in Spring for representing an external resource.

Spring provides following 6 implementations for the Resource interface.

UrlResource
ClassPathResource
FileSystemResource
ServletContextResource
InputStreamResource
ByteArrayResource
We can specify different prefixes for creating path to load resources from different locations.

Prefix                  Example                         Explanation
classpath:       classpath:com/myapp/config.xml     Loaded from the classpath.
file:            file:///data/config.xml            Loaded as a URL from the filesystem.
http:            https://myserver/logo.png          Loaded as a URL.
(none)           /data/config.xml                   Depends on the underlying ApplicationContext.


2. ResourceLoader


It is used for loading resources (e.g. class path or file system resources). It has two methods:

ResourceLoader methods
//Expose the ClassLoader used by this ResourceLoader.
ClassLoader getClassLoader()
 
//Return a Resource handle for the specified resource location.
Resource getResource(String location)
The getResource() method will decide which Resource implementation to instantiate according to the resource path.

To get the reference of ResourceLoader, implement the ResourceLoaderAware interface.

How to get resource
Resource banner = resourceLoader.getResource("file:c:/temp/filesystemdata.txt");
3. Loading resource with ApplicationContext
In Spring, all application contexts implement the ResourceLoader interface. Therefore, all application contexts may be used to obtain Resource instances.

To get the reference of ApplicationContext, implement the ApplicationContextAware interface.

How to get resource
Resource banner = ctx.getResource("file:c:/temp/filesystemdata.txt");

Loading resource with ApplicationContext :

In Spring, all application contexts implement the ResourceLoader interface. Therefore, all application contexts may be used 
to obtain Resource instances.

To get the reference of ApplicationContext, implement the ApplicationContextAware interface.

How to get resource
Resource banner = ctx.getResource("file:c:/temp/filesystemdata.txt");


Loading resource with ResourceLoaderAware
To demonstrate the various examples below, I have placed a file with matching name in different locations and I will show to load each one of them.

CustomResourceLoader.java is written as below which print the content of loaded resource file into console.

CustomResourceLoader.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
 
import org.springframework.context.ResourceLoaderAware;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
 
public class CustomResourceLoader implements ResourceLoaderAware 
{
  private ResourceLoader resourceLoader;
 
  public void setResourceLoader(ResourceLoader resourceLoader) {
    this.resourceLoader = resourceLoader;
  }
 
  public void showResourceData() throws IOException 
  {
    //This line will be changed for all versions of other examples
    Resource banner = resourceLoader.getResource("file:c:/temp/filesystemdata.txt");
 
    InputStream in = banner.getInputStream();
 
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
 
    while (true) {
      String line = reader.readLine();
      if (line == null)
        break;
      System.out.println(line);
    }
    reader.close();
  }
}


And applicationContext.xml file entry for this file is as below:

applicationContext.xml
<bean id="customResourceLoader" class="com.howtodoinjava.demo.CustomResourceLoader"></bean>
To test the CustomResourceLoader bean and call the showResourceData() method, below code has been used:

Main.java
@SuppressWarnings("resource")
public static void main(String[] args) throws Exception 
{
  ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
 
  CustomResourceLoader customResourceLoader = (CustomResourceLoader) context.getBean("customResourceLoader");
 
  customResourceLoader.showResourceData();
}


5. Load external resources
5.1. Load resource from application root folder
To load file from application folder, use below template:

Resource banner = resourceLoader.getResource("file:data.txt");
5.2. Load resource from class path
To load file from classpath, use below template:

Resource banner = resourceLoader.getResource("classpath:classpathdata.txt");
5.3. Load resource from filesystem
To load file from filesystem outside the application folder, use below template:

Resource banner = resourceLoader.getResource("file:c:/temp/filesystemdata.txt");
5.4. Load resource from URL
To load file from any URL, use below template:

Resource banner = resourceLoader.getResource("//howtodoinjava.com/readme.txt");
All above examples will load the resource file from their location and you can use them the way you want.

6. How to inject external files
In above example, we have hard coded the resource name in CustomResourceLoader which many of you may not like and want to make it configurable through context file. Use below code template to make external resource name configurable.

beans.xml
<bean id="customResourceLoader" class="com.howtodoinjava.demo.CustomResourceLoader">
 
  <property name="resource">
    <value>classpath:classpathdata.txt</value>
    <!-- or -->
    <value>file:data.txt</value> 
  </property>
 
</bean>
And CustomResourceLoader will be like below:

CustomResourceLoader.java
public class CustomResourceLoader {
 
  private Resource resource;
 
  public Resource getResource() {
    return resource;
  }
 
  public void setResource(Resource resource) {
    this.resource = resource;
  }
}
Upon context initialization, resource will be injected into ‘resource‘ property of CustomResourceLoader. The same code can be used in spring boot resourceloader example.



16. Spring i18n – ResourceBundleMessageSource


For an application to support internationalization (i18n), it requires the capability of resolving text messages for 
sdifferent locales. Spring’s application context is able to resolve text messages for a target locale by their keys. 
Typically, the messages for one locale should be stored in one separate properties file. This properties file is called a 
resource bundle.

MessageSource is an interface that defines several methods for resolving messages. The ApplicationContext 
interface extends this interface so that all application contexts are able to resolve text messages.

1. Resolve messages using ResourceBundleMessageSource
As an example, you can create the following resource bundle, messages_en_US.properties, for the English language in the United States. Resource bundles will be loaded from the root of the classpath.

1.1. Create resource bundle
Create a file name messages_en_US.properties in classpath of your spring application.

messages_en_US.properties
msg.text=Welcome to howtodoinjava.com
1.2. Configure ResourceBundleMessageSource bean
Now configure ResourceBundleMessageSource class as bean name "messageSource". Additionally, you have to specify the base name of the resource bundles for ResourceBundleMessageSource.

applicationContext.xml
<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name="basename">
        <value>messages</value>
    </property>
</bean>
2. Resource Bundle Lookup Order
For this messageSource definition, if you look up a text message for the United States locale, whose preferred language is English, the resource bundle messages_en_US.properties, which matches both the language and country, will be considered first.
If there’s no such resource bundle or the message can’t be found, the one messages_en.properties that matches the language only will be considered.
If this resource bundle still can’t be found, the default messages.properties for all locales will be chosen finally.
3. Demo – How to use MessageSource
3.1. Fetch the message directly
Now to check if messages can be loaded or not, run this code:

TestSpringContext.java
public class TestSpringContext 
{
    @SuppressWarnings("resource")
    public static void main(String[] args) throws Exception 
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
 
        String message = context.getMessage("msg.text", null, Locale.US);
         
        System.out.println(message);
    }
}
Output:

Console
Welcome to howtodoinjava.com


17. Spring Stereotype Annotations

With @Component, @Repository, @Service and @Controller annotations in place and automatic component scanning enabled, 
Spring will automatically import the beans into the container and inject to dependencies. These annotations are called 
Stereotype annotations as well.

1.1. @Component annotation
The @Component annotation marks a java class as a bean so the component-scanning mechanism of spring can pick it up and pull it into the application context. To use this annotation, apply it over class as below:

@Component
public class EmployeeDAOImpl implements EmployeeDAO {
    ...
}
1.2. @Repository annotation
Although above use of @Component is good enough but we can use more suitable annotation that provides additional benefits specifically for DAOs i.e. @Repository annotation. The @Repository annotation is a specialization of the @Component annotation with similar use and functionality. In addition to importing the DAOs into the DI container, it also makes the unchecked exceptions (thrown from DAO methods) eligible for translation into Spring DataAccessException.

1.3. @Service annotation
The @Service annotation is also a specialization of the component annotation. It doesn’t currently provide any additional behavior over the @Component annotation, but it’s a good idea to use @Service over @Component in service-layer classes because it specifies intent better. Additionally, tool support and additional behavior might rely on it in the future.

1.4. @Controller annotation
@Controller annotation marks a class as a Spring Web MVC controller. It too is a @Component specialization, so beans marked with it are automatically imported into the DI container. When we add the @Controller annotation to a class, we can use another annotation i.e. @RequestMapping; to map URLs to instance methods of a class.


2. Enable component scanning
Above four annotations will be scanned and configured only when they are scanned by DI container of Spring framework. To enable this scanning, we will need to use “context:component-scan” tag in our applicationContext.xml file.

applicationContext.xml
<context:component-scan base-package="com.howtodoinjava.demo.service" />
<context:component-scan base-package="com.howtodoinjava.demo.dao" />
<context:component-scan base-package="com.howtodoinjava.demo.controller" />
The context:component-scan element requires a base-package attribute, which, as its name suggests, specifies a starting point for a recursive component search. We may not want to give top package for scanning to spring, so you should declare three component-scan elements, each with a base-package attribute pointing to a different package.

Difference between @Component and @Bean annotations
In Spring, both annotations are quite different.

@Component used to auto-detect and auto-configure beans using classpath scanning. There’s an implicit one-to-one mapping between the annotated class and the bean (i.e. one bean per class).

@Bean is used to explicitly declare a single bean, rather than letting Spring do it automatically for us.

Another big difference is that @Component is a class level annotation where as @Bean is a method level annotation and ,by default, name of the method serves as the bean name.


18. Spring @Required Annotation


In a production-scale application, there may be hundreds or thousands of beans declared in the IoC container, and the dependencies between them are often very complicated. One of the shortcomings of setter injection is that it’s very hard for you to check if all required properties have been set or not. Using “dependency-check” attribute of <bean> you can check if attributes values have been set but it can’t check if their value is set to null or non-null values.

Apart from verifying dependencies using dependency-check, you can use @Required annotation to check if values set are non-null.

How to use @Required annotation
1) Use @Required annotation over setter methods
Use the @Required annotation over setter method of bean property in class file as below:

EmployeeFactoryBean.java
public class EmployeeFactoryBean extends AbstractFactoryBean<Object> 
{
  private String designation;
   
  public String getDesignation() {
    return designation;
  }
 
  @Required
  public void setDesignation(String designation) {
    this.designation = designation;
  }
   
  //more code here
}

2) Register RequiredAnnotationBeanPostProcessor class
RequiredAnnotationBeanPostProcessor is a spring bean post processor that checks if all the bean properties with the @Required annotation have been set. To enable this bean post processor for property checking, you must register it in the Spring IoC container.

applicationContext.xml
<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" />
Demo
If any property with @Required have not been set, a BeanInitializationException will be thrown by this bean post processor. For example, if I will create an instance of EmployeeFactoryBean class without passing property value for designation, then I will get this error.

applicationContext.xml
<bean id="manager"  class="com.howtodoinjava.demo.factory.EmployeeFactoryBean">
  <!-- <property name="designation" value="Manager" /> -->
</bean>
 
<bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" />
It will throw error.

Console
Caused by: org.springframework.beans.factory.BeanInitializationException: Property 'designation' is required for bean 'manager'
  at org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.postProcessPropertyValues(RequiredAnnotationBeanPostProcessor.java:156)
  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1202)
  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)
  ... 11 more
To correct this problem, pass the designation value by un-commenting the line in applicationContext.xml file.

In this way, you can use @Required annotation and RequiredAnnotationBeanPostProcessor class to verify that on context initialization, all the required bean properties have been set properly.

Which is better constructor injection or setter injection?
The choice between setter and constructor injection is interesting as it mirrors a more general issue with object-oriented programming – should you fill fields in a constructor or with setters.
Constructors with parameters give you a clear statement of what it means to create a valid object in an obvious place. If there’s more than one way to do it, create multiple constructors that show the different combinations. Another advantage with constructor initialization is that it allows you to clearly hide any fields that are immutable by simply not providing a setter. I think this is important – if something shouldn’t change then the lack of a setter communicates this very well. If you use setters for initialization, then this can become a pain.

But If you have a lot of constructor parameters things can look messy, particularly in languages without keyword parameters. If you have multiple ways to construct a valid object, it can be hard to show this through constructors, since constructors can only vary on the number and type of parameters. Constructors also suffer if you have simple parameters such as strings. With setter injection you can give each setter a name to indicate what the string is supposed to do. With constructors you are just relying on the position, which is harder to follow.

My preference is to start with constructor injection, but be ready to switch to setter injection as soon as the problems I’ve outlined above start to become a problem.

7.5. What is Bean Factory ?
A BeanFactory is like a factory class that contains a collection of beans. The BeanFactory holds Bean Definitions of multiple beans within itself and then instantiates the bean whenever asked for by clients.

BeanFactory is able to create associations between collaborating objects as they are instantiated. This removes the burden of configuration from bean itself and the beans client. BeanFactory also takes part in the life cycle of a bean, making calls to custom initialization and destruction methods.

7.6. What is Application Context?
A bean factory is fine to simple applications, but to take advantage of the full power of the Spring framework, you may want to move up to Springs more advanced container, the application context. On the surface, an application context is same as a bean factory.Both load bean definitions, wire beans together, and dispense beans upon request. But it also provides:

A means for resolving text messages, including support for internationalization.
A generic way to load file resources.
Events to beans that are registered as listeners.
7.7. What are the common implementations of the Application Context?
The three commonly used implementation of ApplicationContext are:

ClassPathXmlApplicationContext : It Loads context definition from an XML file located in the classpath, treating context definitions as classpath resources. The application context is loaded from the application’s classpath by using the code .
ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
FileSystemXmlApplicationContext : It loads context definition from an XML file in the filesystem. The application context is loaded from the file system by using the code .
ApplicationContext context = new FileSystemXmlApplicationContext("bean.xml");
XmlWebApplicationContext : It loads context definition from an XML file contained within a web application.
7.8. What should be used preferably BeanFactory or ApplicationContext?
A BeanFactory pretty much just instantiates and configures beans. An ApplicationContext also does that, and it provides the supporting infrastructure to enable lots of enterprise-specific features such as transactions and AOP.

In short, favor the use of an ApplicationContext.


19. Writing REST Controller with Spring WebMVC

Update pom.xml to add support of JAXB and Jackson (for xml and json formats).

<dependency>
  <groupid>org.codehaus.jackson</groupid>
  <artifactid>jackson-mapper-asl</artifactid>
  <version>${jackson-mapper-asl.version}</version>
  <scope>runtime</scope>
</dependency>
 
<dependency>
  <groupid>javax.xml.bind</groupid>
  <artifactid>jaxb-api</artifactid>
  <version>${jaxb-api.version}</version>
  <scope>runtime</scope>
</dependency>


Add ContentNegotiatingViewResolver
Update bean configuration file for view resolvers and add ContentNegotiatingViewResolver.

<mvc:annotation-driven />
 
<context:component-scan  base-package="com.howtodoinjava.web" />
 
<bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
    <property name="mediaTypes">
      <map>
          <entry key="html" value="text/html"></entry>
          <entry key="json" value="application/json"></entry>
          <entry key="xml"  value="application/xml"></entry>
      </map>
    </property>
     <property name="viewResolvers">
        <list>
          <bean class="org.springframework.web.servlet.view.UrlBasedViewResolver">
            <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"></property>
            <property name="prefix" value="/WEB-INF/jsp/"></property>
            <property name="suffix" value=".jsp"></property>
          </bean>
        </list>
    </property>
</bean>

3. Add JAXB annotations in model classes
I am writing 2 classes i.e. Users.java and User.java. These classes will be having JAXB annotations, which will be used by marshaller to convert them in appropriate xml or json formats.

They are for example only and you can write your own classes.

Users.java
package com.howtodoinjava.model;
 
import java.util.Collection;
 
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
 
@XmlRootElement(name="users")
@XmlAccessorType(XmlAccessType.NONE)
public class Users
{
    @XmlElement(name="user")
    private Collection<User> users;
 
    public Collection<User> getUsers() {
        return users;
    }
 
    public void setUsers(Collection<User> users) {
        this.users = users;
    }
}
User.java
package com.howtodoinjava.model;
 
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
 
@XmlRootElement(name="user")
@XmlAccessorType(XmlAccessType.NONE)
public class User {
 
    @XmlElement(name="first-name")
    private String firstName;
 
    @XmlElement(name="last-name")
    private String lastName;
 
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
4. Create REST Controller
The DemoController.java has REST specific annotations for path mappings in request parameters mappings. Also, we will specify the header attributes for request and response.

DemoController.java
@Controller
@RequestMapping("/users")
public class DemoController
{
    @RequestMapping(method = RequestMethod.GET, value="/{id}", headers="Accept=*/*")
    public @ResponseBody User getUserById(@PathVariable String id)
    {
        User user = new User();
        user.setFirstName("john");
        user.setLastName("adward");
        return user;
    }
 
    @RequestMapping(method = RequestMethod.GET,  headers="Accept=*/*")
    public @ResponseBody Users getAllUsers()
    {
        User user1 = new User();
        user1.setFirstName("john");
        user1.setLastName("adward");
 
        User user2 = new User();
        user2.setFirstName("tom");
        user2.setLastName("hanks");
 
        Users users = new Users();
        users.setUsers(new ArrayList<User>());
        users.getUsers().add(user1);
        users.getUsers().add(user2);
 
        return users;
    }
}
5. Demo for spring rest example
Now lets re-deploy the application on tomcat and hit the URL on any REST client. I am using RESTClient. This is a firefox plugin for testing the RESTful webservices.

URL : http://localhost:8080/firstSpringApplication/users



