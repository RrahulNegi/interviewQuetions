Q1) Various State of Object in Hibernate ?

Transient state: An object is in transient state if it just has been instantiated using the new operator and there 
is no reference of it in the database i.e it does not represent any row in the database.

Persistent state: An object is in the persistent state if it has some reference in the database i.e it represent some row in the database
 and identifier value is assigned to it. If any changes are made to the object then hibernate will detect those changes and effects will be
 there in the database that is why the name Persistent. These changes are made when session is closed. A persistent object is in the 
 session scope.

Detached state: An object that has been persistent and is no longer in the session scope. The hibernate will not detect any changes made to
 this object. It can be connected to the session again to make it persistent again.

Q2) How can we make detached object to persistent ?

In this state, hibernate doesn't track the object but you can re-attach a detached object to Hibernate session by calling the update() 
or saveOrUpdate(), or merge() method. Once reattached, the detached object will move to Persistent state.

Q3)Autowiring in spring and types of autowiring ?
In Spring framework, declaring bean dependencies in configuration files is a good practice to follow, so the Spring container is able to 
autowire relationships between collaborating beans. This means that it is possible to automatically let Spring resolve collaborators
 (other beans) for your beans by inspecting the contents of the BeanFactory. This is called spring bean autowiring.

no
This option is default for spring framework and it means that autowiring is OFF. You have to explicitly set the dependencies using <property> tags in bean definitions.

byName
This option enables the dependency injection based on bean names. When autowiring a property in bean, property name is used for searching 
a matching bean definition in configuration file. If such bean is found, it is injected in property. If no such bean is found, a error is 
raised.


byType
This option enables the dependency injection based on bean types. When autowiring a property in bean, property’s class type is used for 
searching a matching bean definition in configuration file. If such bean is found, it is injected in property. If no such bean is found, 
a error is raised.


constructor
Autowiring by constructor is similar to byType, but applies to constructor arguments. In autowire enabled bean, it will look for class 
type of constructor arguments, and then do a autowire bytype on all constructor arguments. Please note that if there isn’t exactly one 
bean of the constructor argument type in the container, a fatal error is raised.

Q4)If two bean are of same type in case of autowiring, what will happen ?

@Autowired
@Qualifier("A1Unmarshaller")
private Jaxb2Marshaller A1Unmarshaller;
The default autowiring is by type, not by name, so when there is more than one bean of the same type, you have to use the @Qualifier annotation.

Q5)How to make a class immutable ?

To create an immutable class in Java, you have to do the following steps.

Declare the class as final so it can’t be extended.
Make all fields private so that direct access is not allowed.
Don’t provide setter methods for variables.
Make all mutable fields final so that its value can be assigned only once.
Initialize all the fields via a constructor performing deep copy.
Perform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.

public final class FinalClassExample {

	private final int id;
	
	private final String name;
	
	private final HashMap<String,String> testMap;
	
	public int getId() {
		return id;
	}


	public String getName() {
		return name;
	}

	/**
	 * Accessor function for mutable objects
	 */
	public HashMap<String, String> getTestMap() {
		//return testMap;
		return (HashMap<String, String>) testMap.clone();
	}

	/**
	 * Constructor performing Deep Copy
	 * @param i
	 * @param n
	 * @param hm
	 */
	
	public FinalClassExample(int i, String n, HashMap<String,String> hm){
		System.out.println("Performing Deep Copy for Object initialization");
		this.id=i;
		this.name=n;
		HashMap<String,String> tempMap=new HashMap<String,String>();
		String key;
		Iterator<String> it = hm.keySet().iterator();
		while(it.hasNext()){
			key=it.next();
			tempMap.put(key, hm.get(key));
		}
		this.testMap=tempMap;
	}
	
	}

Q6) Composition vs Aggregation ?
In both aggregation and composition object of one class "owns" object of another class. But there is a subtle difference: 
Aggregation implies a relationship where the child can exist independently of the parent. ...
 Composition implies a relationship where the child cannot exist independent of the parent.


Q7) Encapculation vs Abstraction ?
Encapsulate hides variables or some implementation that may be changed so often in a class to prevent outsiders access it directly. 
They must access it via getter and setter methods.

Abstraction is used to hiding something too but in a higher degree(class, interface). Clients use an abstract class(or interface) do 
not care about who or which it was, they just need to know what it can do.

Abstraction solve problem in design level while encapsulation solve the problem in implementation level.

Abstraction is used for hiding the unwanted data and giving relevant data. where as encapsulationmeans hiding the code and data into 
single unit to protect the data from outside world.

Abstraction lets you focus on what the object does insted of how it does it.while encapsulation means hiding the internal details of 
how an object does something;

	
Q8) how GWT client intract with GWT Server ?

Q9) Diffrence between factory and abstract factory design pattern ?

Difference between Factory vs Abstract Factory pattern in JavaLet see another example of Abstract Factory and Factory design pattern in 
Java from JDK itself to get a better understanding. If you have done some XML work in Java e.g. reading XML files using DOM parser, you 
may be familiar with DocumentBuilderFactory  class which is an example abstract factory design pattern because it returns a factory called
 DocumentBuilder which then used to create Document.



 
//Example of Abstract Factory and Factory design pattern  in Java
DocumentBuilderFactory abstractFactory = DocumentBuilderFactory.newInstance();
DocumentBuilder factory = abstractFactory.newDocumentBuilder();
Document doc = factory.parse(stocks)

In this example DocumentBuilderFactory (Abstract Factory) creates DocumentBuilder (Factory) which creates Documents (Products).

Let's see some more difference between Abstract Factory and Factory design pattern in Java in point form :

1) One more difference between Abstract Factory and Factory design pattern is that AbstractFactory pattern uses composition to delegate 
responsibility of creating object to another class while Factory design pattern uses inheritance and relies on derived class or sub class 
to create object.

2) Abstract Factory may use Factory design pattern for creating objects but they are not just limited to that they can also use Builder 
design pattern to build object by doing series of steps or Prototype pattern to build object by copying or customizing prototype of that 
object. It completely depends upon your implementation whether to use Factory pattern or Builder pattern for creating products.


When to use Abstract Factory and Factory method design pattern in Java
Factory method design pattern are modern way of creating objects. It offers some notable advantages over new() operator to create Objects e.g. By using Factory method design pattern client is completely decoupled with object creation code, which enforces Encapsulation and result is loosely coupled and highly cohesive system. Any change e.g. a new product from Factory requires almost no change in existing clients. See When to use Factory method design pattern in Java for more scenarios. 

On the other hand if you need an additional level of abstraction over your Factory pattern than Abstract Factory is the right design
 pattern to use. Abstract Factory allows you to use different Factory implementation for different purpose. 

Abstract Factory pattern can be implemented using Factory method and Singleton design pattern in Java. One of the best example of 
Abstract Factory and Factory pattern in Java is DocumentBuilderFactory and DocumentBuilder javax.xml.parsers package.


Q) What is singelton and factory design pattern?

Q10) forward vs sendredirect ?

When we use forward method request is transfer to other resources within the same server for further processing.
In case of sendRedirect request is transfer to another resource to different domain or different server for futher processing.

In case of forward Web container handle all process internally and client or browser is not involved.

When you use SendRedirect container transfers the request to client or browser so url given inside the sendRedirect method is visible as a 
new request to the client.

When forward is called on requestdispather object we pass request and response object so our old request object is present on new resource
 which is going to process our request

In case of SendRedirect call old request and response object is lost because it’s treated as new request by the browser.
Visually we are not able to see the forwarded address, its is transparent
In address bar we are able to see the new redirected address it’s not transparent.

Using forward () method is faster then send redirect.
SendRedirect is slower because one extra round trip is required beasue completely new request is created and old request object is lost.Two browser request requird.

When we redirect using forward and we want to use same data in new resource we can use request.setAttribute () as we have request object available.
But in sendRedirect if we want to use we have to store the data in session or pass along with the URL.
RequestDispatcher rd = request.getRequestDispatcher("pathToResource");
  rd.forward(request, response);

Or

RequestDispatcher rd = servletContext.getRequestDispatcher("/pathToResource");
  rd.forward(request, response);



Q11) What is implisit object?

These Objects are the Java objects that the JSP Container makes available to the developers in each page and the developer can call them directly without being explicitly declared. JSP Implicit Objects are also called pre-defined variables.

1 request

This is the HttpServletRequest object associated with the request.

2	
response

This is the HttpServletResponse object associated with the response to the client.

3	
out

This is the PrintWriter object used to send output to the client.

4	
session

This is the HttpSession object associated with the request.

5	
application

This is the ServletContext object associated with the application context.

6	
config

This is the ServletConfig object associated with the page.

7	
pageContext

This encapsulates use of server-specific features like higher performance JspWriters.

8	
page

This is simply a synonym for this, and is used to call the methods defined by the translated servlet class.

9	
Exception
The Exception object allow


Q12) Servletcontext  vs servletconfig?

The ServletConfig parameters are specified for a particular servlet and are unknown to other servlets. It is used for intializing purposes.

The ServletContext parameters are specified for an entire application outside of any particular servlet and are available to all the servlets within that application. It is application scoped and thus globally accessible across the pages.

Q13) IOC?

Inversion of Control is a principle in software engineering by which the control of objects or portions of a program is transferred to a 
container or framework. It's most often used in the context of object-oriented programming.
By contrast with traditional programming, in which our custom code makes calls to a library, IoC enables a framework to take control of 
the flow of a program and make calls to our custom code. To enable this, frameworks use abstractions with additional behavior built in.

Dependency injection is a pattern through which to implement IoC, where the control being inverted is the setting of object's dependencies.

The act of connecting objects with other objects, or “injecting” objects into other objects, is done by an assembler rather than by the 
objects themselves.

Q14) Joins?
Here are the different types of the JOINs in SQL:

(INNER) JOIN: Returns records that have matching values in both tables
LEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table
RIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table
FULL (OUTER) JOIN: Returns all records when there is a match in either left or right table

Q15) Indexes?

Indexing is a powerful structure in MySQL which can be leveraged to get the fastest response times from common queries. 
MySQL queries achieve efficiency by generating a smaller table, called an index, from a specified column or set of columns. These columns, called a key, can be used to enforce uniqueness

CREATE UNIQUE INDEX index_name ON table_name ( column1, column2,...);

Q16) Function vs Procedure ?

Basic Differences between Stored Procedure and Function in SQL Server. The function must return a value but in Stored Procedure it is optional.
 Even a procedure can return zero or n values. Functions can have only input parameters for it whereas Procedures can have input or 
 output parameters.Sep 15, 2012

Functions can have only input parameters for it whereas Procedures can have input or output parameters.

Functions can be called from Procedure whereas Procedures cannot be called from a Function.

The procedure allows SELECT as well as DML(INSERT/UPDATE/DELETE) statement in it whereas Function allows only SELECT statement in it.

Procedures cannot be utilized in a SELECT statement whereas Function can be embedded in a SELECT statement.

Stored Procedures cannot be used in the SQL statements anywhere in the WHERE/HAVING/SELECT section whereas Function can be.

Functions that return tables can be treated as another rowset. This can be used in JOINs with other tables.

Inline Function can be though of as views that take parameters and can be used in JOINs and other Rowset operations.

An exception can be handled by try-catch block in a Procedure whereas try-catch block cannot be used in a Function.

We can use Transactions in Procedure whereas we can't use Transactions in Function.


Q17) update vs merge?


Hibernate handles persisting any changes to objects in the session when the session is flushed. update can fail if an instance of the 
object is already in the session. Merge should be used in that case. It merges the changes of the detached object with an object in the 
session, if it exists.

Update: if you are sure that the session does not contains an already persistent instance with the same identifier,then use update to 
save the data in hibernate

Merge: if you want to save your modifications at any time with out knowing about the state of an session, then use merge() in hibernate

Update: Suppose we are dealing with any employee object in the same session then we should use update() or saveOrUpdate() method.

Update: if you are sure that the session does not contains an already persistent instance with the same identifier,then use update to save 
the data in hibernate

Merge: Suppose we are creating a session and load an employee object. Now object in session cache. If we close the session at this point 
and we edit state of object and tried to save using update() it will throw exception. To make object persistent we need to open another 
session. Now we load same object again in current session. So if we want to update present object with previous object changes we have to 
use merge() method. Merge method will merge changes of both states of object and will save in database.

Q18) Internal working of hashset and hashmap ?

Q19)Garbage collectors ?
An object becomes eligible for Garbage collection or GC if it's not reachable from any live threads or by any static references. 
In other words, you can say that an object becomes eligible for garbage collection if all references are null. Cyclic dependencies are 
not counted as the reference so if object A has a reference to object B and object B has a reference to Object A and they don't have any 
other live reference then both Objects A and B will be eligible for Garbage collection.

Generally, an object becomes eligible for garbage collection in Java on the following cases:

1) All references to that object explicitly set to null e.g. object = null

2) The object is created inside a block and reference goes out scope once control exit that block.

3) Parent object set to null if an object holds the reference to another object and when you set the container object's reference null, child or contained object automatically becomes eligible for garbage collection.

4) If an object has only lived weak references via WeakHashMap it will be eligible for garbage collection.

Java objects are created in Heap and Heap is divided into three parts or generations for the sake of garbage collection in Java, these are called as a Young generation, Tenured or Old Generation and Perm Area of the heap.  New Generation is further divided into three parts known as Eden space, Survivor 1, and Survivor 2 space.

When an object first created in heap its gets created in a new generation inside Eden space and after subsequent minor garbage collection if an object survives its gets moved to survivor 1 and then survivor 2 before major garbage collection moved that object to old or tenured generation.

heap structure and generation in Java for GC


Permanent generation of Heap or Perm Area of Heap is somewhat special and it is used to store Metadata related to classes and method in JVM, it also hosts String pool provided by JVM as discussed in my string tutorial why String is immutable in Java.

There are many opinions around whether garbage collection in Java happens in perm area of Java heap or not, as per my knowledge this is something which is JVM dependent and happens at least in Sun's implementation of JVM. You can also try this by just creating millions of String and watching for Garbage collection or OutOfMemoryError.


Types of Garbage Collector in Java
Java Runtime (J2SE 5) provides various types of Garbage collection in Java which you can choose based on your application's performance requirement. Java 5 adds three additional garbage collectors except for serial garbage collector. Each is a generational garbage collector that has been implemented to increase the throughput of the application or to reduce garbage collection pause times.

1) Throughput Garbage Collector: This garbage collector in Java uses a parallel version of the young generation collector. It is used if the -XX:+UseParallelGC option is passed to the runtime via JVM command-line options. The tenured generation collector is the same as the serial collector.

2) Concurrent low pause Collector: This Collector is used if the -Xingc or -XX:+UseConcMarkSweepGC is passed on the command line. This is also referred to as the Concurrent Mark Sweep Garbage collector. The concurrent collector is used to collect the tenured generation and does most of the collection concurrently with the execution of the application. The application is paused for short periods during the collection.

A parallel version of the young generation copying collector is used with the concurrent collector. Concurrent Mark Sweep Garbage collector is the most widely used garbage collector in java and it uses an algorithm to first mark object which needs to collect when garbage collection triggers.

3) The Incremental (Sometimes called train) low pause collector: This collector is used only if -XX:+UseTrainGC is passed on the command line. This garbage collector has not changed since the java 1.4.2 and is currently not under active development. It will not be supported in future releases so avoid using this and please see 1.4.2 GC Tuning document for information on this collector.

An important point to note is that -XX:+UseParallelGC should not be used with -XX:+UseConcMarkSweepGC. The argument parsing in the J2SE Platform starting with version 1.4.2 should only allow the legal combination of command-line options for garbage collector but earlier releases may not find or detect all illegal combinations and the results for illegal combinations are unpredictable. It’s not recommended to use this garbage collector in java.


Read more: https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html#ixzz6Qpk5ZGqc
Q20) Create own linkedlist ?

public class CrunchifyLinkedListTest {
	public static CrunchifyLinkedList crunchifyList;
 
	public static void main(String[] args) {
 
		// Default constructor - let's put "0" into head element.
		crunchifyList = new CrunchifyLinkedList();
 
		// add more elements to LinkedList
		crunchifyList.add("1");
		crunchifyList.add("2");
		crunchifyList.add("3");
		crunchifyList.add("4");
		crunchifyList.add("5");
 
		/*
		 * Please note that primitive values can not be added into LinkedList directly. They must be converted to their
		 * corresponding wrapper class.
		 */
 
		System.out.println("Print: crunchifyList: \t\t" + crunchifyList);
		System.out.println(".size(): \t\t\t\t" + crunchifyList.size());
		System.out.println(".get(3): \t\t\t\t" + crunchifyList.get(3) + " (get element at index:3 - list starts from 0)");
		System.out.println(".remove(2): \t\t\t\t" + crunchifyList.remove(2) + " (element removed)");
		System.out.println(".get(3): \t\t\t\t" + crunchifyList.get(3) + " (get element at index:3 - list starts from 0)");
		System.out.println(".size(): \t\t\t\t" + crunchifyList.size());
		System.out.println("Print again: crunchifyList: \t" + crunchifyList);
	}
 
}
 
class CrunchifyLinkedList {
 
	private static int counter;
	private Node head;
 
	// Default constructor
	public CrunchifyLinkedList() {
 
	}
 
	// appends the specified element to the end of this list.
	public void add(Object data) {
 
		// Initialize Node only incase of 1st element
		if (head == null) {
			head = new Node(data);
		}
 
		Node crunchifyTemp = new Node(data);
		Node crunchifyCurrent = head;
 
		// Let's check for NPE before iterate over crunchifyCurrent
		if (crunchifyCurrent != null) {
 
			// starting at the head node, crawl to the end of the list and then add element after last node
			while (crunchifyCurrent.getNext() != null) {
				crunchifyCurrent = crunchifyCurrent.getNext();
			}
 
			// the last node's "next" reference set to our new node
			crunchifyCurrent.setNext(crunchifyTemp);
		}
 
		// increment the number of elements variable
		incrementCounter();
	}
 
	private static int getCounter() {
		return counter;
	}
 
	private static void incrementCounter() {
		counter++;
	}
 
	private void decrementCounter() {
		counter--;
	}
 
	// inserts the specified element at the specified position in this list
	public void add(Object data, int index) {
		Node crunchifyTemp = new Node(data);
		Node crunchifyCurrent = head;
 
		// Let's check for NPE before iterate over crunchifyCurrent
		if (crunchifyCurrent != null) {
			// crawl to the requested index or the last element in the list, whichever comes first
			for (int i = 0; i < index && crunchifyCurrent.getNext() != null; i++) {
				crunchifyCurrent = crunchifyCurrent.getNext();
			}
		}
 
		// set the new node's next-node reference to this node's next-node reference
		crunchifyTemp.setNext(crunchifyCurrent.getNext());
 
		// now set this node's next-node reference to the new node
		crunchifyCurrent.setNext(crunchifyTemp);
 
		// increment the number of elements variable
		incrementCounter();
	}
 
	public Object get(int index)
	// returns the element at the specified position in this list.
	{
		// index must be 1 or higher
		if (index < 0)
			return null;
		Node crunchifyCurrent = null;
		if (head != null) {
			crunchifyCurrent = head.getNext();
			for (int i = 0; i < index; i++) {
				if (crunchifyCurrent.getNext() == null)
					return null;
 
				crunchifyCurrent = crunchifyCurrent.getNext();
			}
			return crunchifyCurrent.getData();
		}
		return crunchifyCurrent;
 
	}
 
	// removes the element at the specified position in this list.
	public boolean remove(int index) {
 
		// if the index is out of range, exit
		if (index < 1 || index > size())
			return false;
 
		Node crunchifyCurrent = head;
		if (head != null) {
			for (int i = 0; i < index; i++) {
				if (crunchifyCurrent.getNext() == null)
					return false;
 
				crunchifyCurrent = crunchifyCurrent.getNext();
			}
			crunchifyCurrent.setNext(crunchifyCurrent.getNext().getNext());
 
			// decrement the number of elements variable
			decrementCounter();
			return true;
 
		}
		return false;
	}
 
	// returns the number of elements in this list.
	public int size() {
		return getCounter();
	}
 
	public String toString() {
		String output = "";
 
		if (head != null) {
			Node crunchifyCurrent = head.getNext();
			while (crunchifyCurrent != null) {
				output += "[" + crunchifyCurrent.getData().toString() + "]";
				crunchifyCurrent = crunchifyCurrent.getNext();
			}
 
		}
		return output;
	}
 
	private class Node {
		// reference to the next node in the chain, or null if there isn't one.
		Node next;
 
		// data carried by this node. could be of any type you need.
		Object data;
 
		// Node constructor
		public Node(Object dataValue) {
			next = null;
			data = dataValue;
		}
 
		// another Node constructor if we want to specify the node to point to.
		@SuppressWarnings("unused")
		public Node(Object dataValue, Node nextValue) {
			next = nextValue;
			data = dataValue;
		}
 
		// these methods should be self-explanatory
		public Object getData() {
			return data;
		}
 
		@SuppressWarnings("unused")
		public void setData(Object dataValue) {
			data = dataValue;
		}
 
		public Node getNext() {
			return next;
		}
 
		public void setNext(Node nextValue) {
			next = nextValue;
		}
 
	}
}

Q21) Stribg vs stringbuilder vs sting buffer ?

String is immutable whereas StringBuffer and StringBuilder are mutable classes.
StringBuffer is thread-safe and synchronized whereas StringBuilder is not. That’s why StringBuilder is faster than StringBuffer.
String concatenation operator (+) internally uses StringBuffer or StringBuilder class.
For String manipulations in a non-multi threaded environment, we should use StringBuilder else use StringBuffer class


Q22) What is hashcode ?

The hashcode of a Java Object is simply a number, it is 32-bit signed int, that allows an object to be managed by a hash-based data 
structure. We know that hash code is an unique id number allocated to an object by JVM. But actually speaking,
 Hash code is not an unique number for an object. If two objects are equals then these two objects should return same hash code.
 So we have to implement hashcode() method of a class in such way that if two objects are equals, ie compared by equal() 
 method of that class, then those two objects must return same hash code. If you are overriding hashCode you need to
 override equals method also.

Q23) Iterate hashmap in java ?

-Iterating over Map.entrySet() using For-Each loop :
 Map<String,String> gfg = new HashMap<String,String>(); 
      
        // enter name/url pair 
        gfg.put("GFG", "geeksforgeeks.org"); 
        gfg.put("Practice", "practice.geeksforgeeks.org"); 
        gfg.put("Code", "code.geeksforgeeks.org"); 
        gfg.put("Quiz", "quiz.geeksforgeeks.org"); 
          
        // using for-each loop for iteration over Map.entrySet() 
        for (Map.Entry<String,String> entry : gfg.entrySet())  
            System.out.println("Key = " + entry.getKey() + 
                             ", Value = " + entry.getValue()); 
    } 
	
- Iterating over keys or values using keySet() and values() methods

 // using keySet() for iteration over keys 
        for (String name : gfg.keySet())  
            System.out.println("key: " + name); 
          
        // using values() for iteration over keys 
        for (String url : gfg.values())  
            System.out.println("value: " + url); 
    } 

-Iterating using iterators over Map.Entry<K, V>
/ using iterators 
        Iterator<Map.Entry<String, String>> itr = gfg.entrySet().iterator(); 
          
        while(itr.hasNext()) 
        { 
             Map.Entry<String, String> entry = itr.next(); 
             System.out.println("Key = " + entry.getKey() +  
                                 ", Value = " + entry.getValue()); 
        } 

- Using forEach(action) method :

        gfg.forEach((k,v) -> System.out.println("Key = "
                + k + ", Value = " + v)); 

- Iterating over keys and searching for values (inefficient)

// looping over keys 
        for (String name : gfg.keySet())  
        { 
            // search  for value 
            String url = gfg.get(name); 
            System.out.println("Key = " + name + ", Value = " + url); 
        }

Q24) String litteral vs String using new ?

Both expression gives you String object, but there is subtle difference between them. When you create String object using new() operator,
 it always create a new object in heap memory. On the other hand, if you create object using String literal syntax e.g. "Java", it may 
 return an existing object from String pool (a cache of String object in Perm gen space, which is now moved to heap space in recent Java 
 release), if it's already exists. Otherwise it will create a new string object and put in string pool for future re-use. In rest of this 
 article, why it is one of the most important thing you should remember about String in Java.



What is String literal and String Pool
Since String is one of the most used type in any application, Java designer took a step further to optimize uses of this class. 
They know that Strings will not going to be cheap, and that's why they come up with an idea to cache all String instances created 
inside double quotes e.g. "Java". These double quoted literal is known as String literal and the cache which stored these String 
instances are known as as String pool. In earlier version of Java, I think up-to Java 1.6 String pool is located in permgen area of
 heap, but in Java 1.7 updates its moved to main heap area. Earlier since it was in PermGen space, it was always a risk to create too 
 many String object, because its a very limited space, default size 64 MB and used to store class metadata e.g. .class files. Creating 
 too many String literals can cause java.lang.OutOfMemory: permgen space. Now because String pool is moved to a much larger memory space, 
 it's much more safe. By the way, don't misuse memory here, always try to minimize temporary String object e.g. "a", "b" and then "ab". 
 Always use StringBuilder to deal with temporary String object.


Difference between String literal and String object
String literal vs New String in Java
At high level both are String object, but main difference comes from the point that new() operator always creates a new String object. Also when you create String using literal they are interned. This will be much more clear when you compare two String objects created using String literal and new operator, as shown in below example :

String a = "Java";
String b = "Java";
System.out.println(a == b);  // True

Here two different objects are created and they have different references:

String c = new String("Java");
String d = new String("Java");
System.out.println(c == d);  // False

Similarly when you compare a String literal with an String object created using new() operator using == operator, it will return false, as shown below :

String e = "JDK";
String f =  new String("JDK");
System.out.println(e == f);  // False

In general you should use the string literal notation when possible. It is easier to read and it gives the compiler a chance to optimize your code. By the way any answer to this question is incomplete until you explain what is String interning, so let's see that in next section.

String interning using inter() method
Java by default doesn't put all String object into String pool, instead they gives you flexibility to explicitly store any arbitrary object in String pool. You can put any object to String pool by calling intern() method of java.lang.String class. Though, when you create using String literal notation of Java, it automatically call intern() method to put that object into String pool, provided it was not present in the pool already. This is another difference between string literal and new string, because in case of new, interning doesn't happen automatically, until you call intern() method on that object. Also don't forget to use StringBuffer and StringBuilder for string concatenation, they will reduce number


That's all about this question, what is difference between String literal and String object in Java. Always remember that literal Strings are returned from string pool and Java put them in pool if not stored already. This difference is most obvious, when you compare two String objects using equality operator (==). That's why it's suggested as always compare two String object using equals() method and never compare them using == operator, because you never know which one is coming from pool and which one is created using new() operator. If you know the difference between string object and string literal, you can also solve questions from Java written test, which also test this concept. It's something, every Java programmer should know.  of temporary String object in heap space.

Q25) implements Singelton ?

1. Eager initialization
In eager initialization, the instance of Singleton Class is created at the time of class loading, this is the easiest method to create a 
singleton class but it has a drawback that instance is created even though client application might not be using it.

Here is the implementation of the static initialization singleton class.


package com.journaldev.singleton;

public class EagerInitializedSingleton {
    
    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();
    
    //private constructor to avoid client applications to use constructor
    private EagerInitializedSingleton(){}

    public static EagerInitializedSingleton getInstance(){
        return instance;
    }
}
If your singleton class is not using a lot of resources, this is the approach to use. But in most of the scenarios, Singleton classes are
 created for resources such as File System, Database connections, etc. We should avoid the instantiation until unless client calls the 
getInstance method. Also, this method doesn’t provide any options for exception handling.


2. Static block initialization
Static block initialization implementation is similar to eager initialization, except that instance of class is created in the static block that provides option for exception handling.


package com.journaldev.singleton;

public class StaticBlockSingleton {

    private static StaticBlockSingleton instance;
    
    private StaticBlockSingleton(){}
    
    //static block initialization for exception handling
    static{
        try{
            instance = new StaticBlockSingleton();
        }catch(Exception e){
            throw new RuntimeException("Exception occured in creating singleton instance");
        }
    }
    
    public static StaticBlockSingleton getInstance(){
        return instance;
    }
}
Both eager initialization and static block initialization creates the instance even before it’s being used and that is not the best
 practice to use. So in further sections, we will learn how to create a Singleton class that supports lazy initialization.

Read: Java static


3. Lazy Initialization
Lazy initialization method to implement Singleton pattern creates the instance in the global access method. Here is the sample code for creating Singleton class with this approach.


package com.journaldev.singleton;

public class LazyInitializedSingleton {

    private static LazyInitializedSingleton instance;
    
    private LazyInitializedSingleton(){}
    
    public static LazyInitializedSingleton getInstance(){
        if(instance == null){
            instance = new LazyInitializedSingleton();
        }
        return instance;
    }
}
The above implementation works fine in case of the single-threaded environment but when it comes to multithreaded systems, 
it can cause issues if multiple threads are inside the if condition at the same time. It will destroy the singleton pattern and 
both threads will get the different instances of the singleton class. In next section, we will see different ways to create a
 thread-safe singleton class.


4. Thread Safe Singleton
The easier way to create a thread-safe singleton class is to make the global access method synchronized, so that only one thread can execute this method at a time. General implementation of this approach is like the below class.


package com.journaldev.singleton;

public class ThreadSafeSingleton {

    private static ThreadSafeSingleton instance;
    
    private ThreadSafeSingleton(){}
    
    public static synchronized ThreadSafeSingleton getInstance(){
        if(instance == null){
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
    
}
Above implementation works fine and provides thread-safety but it reduces the performance because of the cost associated with the 
synchronized method, although we need it only for the first few threads who might create the separate instances 
(Read: Java Synchronization). To avoid this extra overhead every time, double checked locking principle is used.
 In this approach, the synchronized block is used inside the if condition with an additional check to ensure that only one instance of a singleton class is created.

The following code snippet provides the double-checked locking implementation.


public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(instance == null){
        synchronized (ThreadSafeSingleton.class) {
            if(instance == null){
                instance = new ThreadSafeSingleton();
            }
        }
    }
    return instance;
}
Read: Thread Safe Singleton Class


5. Bill Pugh Singleton Implementation
Prior to Java 5, java memory model had a lot of issues and the above approaches used to fail in certain scenarios where too many 
threads try to get the instance of the Singleton class simultaneously. So Bill Pugh came up with a different approach to create the 
Singleton class using an inner static helper class. The Bill Pugh Singleton implementation goes like this;


package com.journaldev.singleton;

public class BillPughSingleton {

    private BillPughSingleton(){}
    
    private static class SingletonHelper{
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }
    
    public static BillPughSingleton getInstance(){
        return SingletonHelper.INSTANCE;
    }
}
Notice the private inner static class that contains the instance of the singleton class. When the singleton class is loaded, 
SingletonHelper class is not loaded into memory and only when someone calls the getInstance method, this class gets loaded and creates 
the Singleton class instance.

This is the most widely used approach for Singleton class as it doesn’t require synchronization. I am using this approach in many of my
 projects and it’s easy to understand and implement also.

Read: Java Nested Classes


6. Using Reflection to destroy Singleton Pattern
Reflection can be used to destroy all the above singleton implementation approaches. Let’s see this with an example class.


package com.journaldev.singleton;

import java.lang.reflect.Constructor;

public class ReflectionSingletonTest {

    public static void main(String[] args) {
        EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance();
        EagerInitializedSingleton instanceTwo = null;
        try {
            Constructor[] constructors = EagerInitializedSingleton.class.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                //Below code will destroy the singleton pattern
                constructor.setAccessible(true);
                instanceTwo = (EagerInitializedSingleton) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }

}
When you run the above test class, you will notice that hashCode of both the instances is not same that destroys the singleton pattern. 
Reflection is very powerful and used in a lot of frameworks like Spring and Hibernate, do check out Java Reflection Tutorial.


7. Enum Singleton
To overcome this situation with Reflection, Joshua Bloch suggests the use of Enum to implement Singleton design pattern as 
Java ensures that any enum value is instantiated only once in a Java program. Since Java Enum values are globally accessible, so is the 
singleton. The drawback is that the enum type is somewhat inflexible; for example, it does not allow lazy initialization.


package com.journaldev.singleton;

public enum EnumSingleton {

    INSTANCE;
    
    public static void doSomething(){
        //do something
    }
}
Read: Java Enum


8. Serialization and Singleton
Sometimes in distributed systems, we need to implement Serializable interface in Singleton class so that we can store its state in the 
file system and retrieve it at a later point of time. Here is a small singleton class that implements Serializable interface also.


package com.journaldev.singleton;

import java.io.Serializable;

public class SerializedSingleton implements Serializable{

    private static final long serialVersionUID = -7604766932017737115L;

    private SerializedSingleton(){}
    
    private static class SingletonHelper{
        private static final SerializedSingleton instance = new SerializedSingleton();
    }
    
    public static SerializedSingleton getInstance(){
        return SingletonHelper.instance;
    }
    
}
The problem with serialized singleton class is that whenever we deserialize it, it will create a new instance of the class.
 Let’s see it with a simple program.


package com.journaldev.singleton;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;

public class SingletonSerializedTest {

    public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
        SerializedSingleton instanceOne = SerializedSingleton.getInstance();
        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(
                "filename.ser"));
        out.writeObject(instanceOne);
        out.close();
        
        //deserailize from file to object
        ObjectInput in = new ObjectInputStream(new FileInputStream(
                "filename.ser"));
        SerializedSingleton instanceTwo = (SerializedSingleton) in.readObject();
        in.close();
        
        System.out.println("instanceOne hashCode="+instanceOne.hashCode());
        System.out.println("instanceTwo hashCode="+instanceTwo.hashCode());
        
    }

}
The output of the above program is;


instanceOne hashCode=2011117821
instanceTwo hashCode=109647522
So it destroys the singleton pattern, to overcome this scenario all we need to do it provide the implementation of readResolve() method.


protected Object readResolve() {
    return getInstance();
}

Q26) Object has copy of refrence or value>?

Object references are passed by value
All object references in Java are passed by value. This means that a copy of the value will be passed to a method. But the trick is that 
passing a copy of the value also changes the real value of the object. To understand why, start with this example:


public class ObjectReferenceExample {

	public static void main(String... doYourBest) {
    	    Simpson simpson = new Simpson();
    	    transformIntoHomer(simpson);
    	    System.out.println(simpson.name);
	}

	static void transformIntoHomer(Simpson simpson) {
    	    simpson.name = "Homer";
	}

}

class Simpson {
	String name;
}
What do you think the simpson.name will be after the transformIntoHomer method is executed?

[ Also on InfoWorld: What is Kotlin? The Java alternative explained ]
In this case, it will be Homer! The reason is that Java object variables are simply references that point to real objects in the memory 
heap. Therefore, even though Java passes parameters to methods by value, if the variable points to an object reference, the real object 
will also be changed.

If you’re still not quite clear how this works, take a look at the figure below.

Flow diagram of object references in JavaRafael Chinelato Del Nero
Are primitive types passed by value?
Like object types, primitive types are also passed by value. Can you deduce what will happen to the primitive types in the following code 
example?


public class PrimitiveByValueExample {

	public static void main(String... primitiveByValue) {
    	    int homerAge = 30;
    	    changeHomerAge(homerAge);
    	    System.out.println(homerAge);
	}

	static void changeHomerAge(int homerAge) {
    	    homerAge = 35;
	}
}
If you determined that the value would change to 30, you are correct. It’s 30 because (again) Java passes object parameters by value. 
The number 30 is just a copy of the value, not the real value. Primitive types are allocated in the stack memory, so only the local 
value will be changed. In this case, there is no object reference.

Q) JDK vs JVM ?
Differences between JDK, JRE and JVM

Difficulty Level : Easy
Last Updated : 03 Jun, 2022
Java Development Kit (JDK) is a software development environment used for developing Java applications and applets. 
It includes the Java Runtime Environment (JRE), an interpreter/loader (Java), a compiler (javac), an archiver (jar), a
 documentation generator (Javadoc), and other tools needed in Java development. 

Now we need an environment to make a run of our program. Henceforth, JRE stands for “Java Runtime Environment” and may also be written as “Java RTE.” The Java Runtime Environment provides the minimum requirements for executing a Java application; it consists of the Java Virtual Machine (JVM), core classes, and supporting files. 

Now let us discuss JVM, which stands out for java virtual machine. It is as follows:

A specification where the working of Java Virtual Machine is specified. But implementation provider is independent to choose the algorithm. Its implementation has been provided by Sun and other companies.
An implementation is a computer program that meets the requirements of the JVM specification.
Runtime Instance Whenever you write a java command on the command prompt to run the java class, an instance of JVM is created.
Before proceeding to the differences between JDK, JRE, and JVM, let us discuss them in brief first and interrelate them with the image below being proposed.



Don’t get confused as we are going to discuss all of them one by one.

1. JDK (Java Development Kit) is a Kit that provides the environment to develop and execute(run) the Java program. 
JDK is a kit(or package) that includes two things

Development Tools(to provide an environment to develop your java programs)
JRE (to execute your java program).
 
2. JRE (Java Runtime Environment) is an installation package that provides an environment to only run(not develop) 
the java program(or application)onto your machine. JRE is only used by those who only want to run Java programs that 
are end-users of your system.
 

3. JVM (Java Virtual Machine) is a very important part of both JDK and JRE because it is contained or inbuilt in both. 
Whatever Java program you run using JRE or JDK goes into JVM and JVM is responsible for executing the java program line 
by line, hence it is also known as an interpreter.

Now let us discuss the components of JRE in order to understand its importance of it and perceive how it actually works. For this let us discuss components.

The components of JRE are as follows:

Deployment technologies, including deployment, Java Web Start, and Java Plug-in.
User interface toolkits, including Abstract Window Toolkit (AWT), Swing, Java 2D, Accessibility, Image I/O, Print Service, Sound, drag, and drop (DnD), and input methods.
Integration libraries, including Interface Definition Language (IDL), Java Database Connectivity (JDBC), Java Naming and Directory Interface (JNDI), Remote Method Invocation (RMI), Remote Method Invocation Over Internet Inter-Orb Protocol (RMI-IIOP), and scripting.
Other base libraries, including international support, input/output (I/O), extension mechanism, Beans, Java Management Extensions (JMX), Java Native Interface (JNI), Math, Networking, Override Mechanism, Security, Serialization, and Java for XML Processing (XML JAXP).
Lang and util base libraries, including lang and util, management, versioning, zip, instrument, reflection, Collections, Concurrency Utilities, Java Archive (JAR), Logging, Preferences API, Ref Objects, and Regular Expressions.
Java Virtual Machine (JVM), including Java HotSpot Client and Server Virtual Machines.
After having an adequate understanding of the components, now let us discuss the working of JRE. In order to understand how JRE works, let us consider an illustration below as follows:

Illustration:

Consider a java source file saved as ‘Example.java’. The file is compiled into a set of Byte Code that is stored in 
a “.class” file. Here it will be “Example.class“. 

Compile time

Note: From above, media operation computing during the compile time can be interpreted.

The following actions occur at runtime as listed below:

Class Loader
Byte Code Verifier
Interpreter
Execute the Byte Code
Q27) Structure of JVM?

Every Java developer knows that bytecode will be executed by the JRE (Java Runtime Environment). But many don't know the 
fact that JRE is the implementation of Java Virtual Machine (JVM), which analyzes the bytecode, interprets the code, and executes it. It is very 
important, as a developer, that we know the architecture of the JVM, as it enables us to write code more efficiently. In this article, 
we will learn more deeply about the JVM architecture in Java and different components of the JVM.

What Is the JVM?
A Virtual Machine is a software implementation of a physical machine. Java was developed with the concept of WORA 
(Write Once Run Anywhere), which runs on a VM. The compiler compiles the Java file into a Java .class file, then 
that .class file is input into the JVM, which loads and executes the class file. Below is a diagram of the Architecture of the JVM.

JVM Architecture Diagram
JVM Architecture Diagram

How Does the JVM Work?
As shown in the above architecture diagram, the JVM is divided into three main subsystems:

ClassLoader Subsystem
Runtime Data Area
Execution Engine

1. ClassLoader Subsystem
Java's dynamic class loading functionality is handled by the ClassLoader subsystem. It loads, links. and initializes the class file
 when it refers to a class for the first time at runtime, not compile time.

1.1 Loading
Classes will be loaded by this component. BootStrap ClassLoader, Extension ClassLoader, and Application ClassLoader are the three 
ClassLoaders that will help in achieving it.

BootStrap ClassLoader – Responsible for loading classes from the bootstrap classpath, nothing but rt.jar. Highest priority will be given 
to this loader.

Extension ClassLoader – Responsible for loading classes which are inside the ext folder (jre\lib).

Application ClassLoader –Responsible for loading Application Level Classpath, path mentioned Environment Variable, etc.

The above ClassLoaders will follow Delegation Hierarchy Algorithm while loading the class files.

1.2 Linking
Verify – Bytecode verifier will verify whether the generated bytecode is proper or not if verification fails we will get the verification
 error.
Prepare – For all static variables memory will be allocated and assigned with default values.

Resolve – All symbolic memory references are replaced with the original references from Method Area.

1.3 Initialization
This is the final phase of ClassLoading; here, all static variables will be assigned with the original values, and the static block will 
be executed.

2. Runtime Data Area
The Runtime Data Area is divided into five major components:

Method Area – All the class-level data will be stored here, including static variables. There is only one method area per JVM, and it is a
 shared resource.
 
Heap Area – All the Objects and their corresponding instance variables and arrays will be stored here. There is also one Heap Area per JVM.
 Since the Method and Heap areas share memory for multiple threads, the data stored is not thread-safe.
 
Stack Area – For every thread, a separate runtime stack will be created. For every method call, one entry will be made in the stack memory 
which is called Stack Frame. All local variables will be created in the stack memory. The stack area is thread-safe since it is not a 
shared resource. The Stack Frame is divided into three subentities:

Local Variable Array – Related to the method how many local variables are involved and the corresponding values will be stored here.
Operand stack – If any intermediate operation is required to perform, operand stack acts as runtime workspace to perform the operation.
Frame data – All symbols corresponding to the method is stored here. In the case of any exception, the catch block information will be maintained in the frame data.

PC Registers – Each thread will have separate PC Registers, to hold the address of current executing instruction once the instruction is 
executed the PC register will be updated with the next instruction.

Native Method stacks – Native Method Stack holds native method information. For every thread, a separate native method stack will be 
created.

3. Execution Engine
The bytecode, which is assigned to the Runtime Data Area, will be executed by the Execution Engine. The Execution Engine reads the 
bytecode and executes it piece by piece.

Interpreter – The interpreter interprets the bytecode faster but executes slowly. The disadvantage of the interpreter is that when one
 method is called multiple times, every time a new interpretation is required.
 
JIT Compiler – The JIT Compiler neutralizes the disadvantage of the interpreter. The Execution Engine will be using the help of the 
interpreter in converting byte code, but when it finds repeated code it uses the JIT compiler, which compiles the entire bytecode and
 changes it to native code. This native code will be used directly for repeated method calls, which improve the 
 performance of the system.
 
Intermediate Code Generator – Produces intermediate code
Code Optimizer – Responsible for optimizing the intermediate code generated above
Target Code Generator – Responsible for Generating Machine Code or Native Code
Profiler – A special component, responsible for finding hotspots, i.e. whether the method is called multiple times or not.
Garbage Collector: Collects and removes unreferenced objects. Garbage Collection can be triggered by calling System.gc(), but the execution is not guaranteed. Garbage collection of the JVM collects the objects that are created.
Java Native Interface (JNI): JNI will be interacting with the Native Method Libraries and provides the Native Libraries required for the Execution Engine.

Native Method Libraries: This is a collection of the Native Libraries, which is required for the Execution Engine.


Q28) Cretae a custom exception ?

public class EmailNotUniqueException extends Exception {

    public EmailNotUniqueException(String message) {
        super(message);
    }
}

Q29) Throw vs Throws ?

1. Throws clause is used to declare an exception, which means it works similar to the try-catch block. On the other hand throw keyword 
is used to throw an exception explicitly.

2. If we see syntax wise than throw is followed by an instance of Exception class and throws is followed by exception class names.
For example:

throw new ArithmeticException("Arithmetic Exception");
and


Report Ad
throws ArithmeticException;
3. Throw keyword is used in the method body to throw an exception, while throws is used in method signature to declare the exceptions that can occur in the statements present in the method.

For example:
Throw:

...
void myMethod() {
   try {
      //throwing arithmetic exception using throw
      throw new ArithmeticException("Something went wrong!!");
   } 
   catch (Exception exp) {
      System.out.println("Error: "+exp.getMessage());
   }
}
...
Throws:

...
//Declaring arithmetic exception using throws
void sample() throws ArithmeticException{
   //Statements
}
...
4. You can throw one exception at a time but you can handle multiple exceptions by declaring them using throws keyword.
For example:
Throw:

void myMethod() {
   //Throwing single exception using throw
   throw new ArithmeticException("An integer should not be divided by zero!!");
}
..
Throws:

//Declaring multiple exceptions using throws
void myMethod() throws ArithmeticException, NullPointerException{
   //Statements where exception might occur
}


Q30)Why we use searalization ?

Serialization in Java allows us to convert an Object to stream that we can send over the network or save it as file or store in DB for 
later usage. Deserialization is the process of converting Object stream to actual Java Object to be used in our program. Serialization 
in Java seems very easy to use at first but it comes with some trivial security and integrity issues that we will look in the later part 
of this article. We will look into following topics in this tutorial.

Serializable in Java
Class Refactoring with Serialization and serialVersionUID
Java Externalizable Interface
Java Serialization Methods
Serialization with Inheritance
Serialization Proxy Pattern

Serializable in Java
If you want a class object to be serializable, all you need to do it implement the java.io.Serializable interface. Serializable in java 
is a marker interface and has no fields or methods to implement. It’s like an Opt-In process through which we make our classes 
serializable.

Serialization in java is implemented by ObjectInputStream and ObjectOutputStream, so all we need is a wrapper over them to either save it to file or send it over the network. Let’s see a simple Serialization in java program example.


package com.journaldev.serialization;

import java.io.Serializable;

public class Employee implements Serializable {

//	private static final long serialVersionUID = -6470090944414208496L;
	
	private String name;
	private int id;
	transient private int salary;
//	private String password;
	
	@Override
	public String toString(){
		return "Employee{name="+name+",id="+id+",salary="+salary+"}";
	}
	
	//getter and setter methods
	
}
Notice that it’s a simple java bean with some properties and getter-setter methods. If you want an object property to be not 
serialized to stream, you can use transient keyword like I have done with salary variable.

Now suppose we want to write our objects to file and then deserialize it from the same file. So we need utility methods that will use 
ObjectInputStream and ObjectOutputStream for serialization purposes.


package com.journaldev.serialization;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/**
 * A simple class with generic serialize and deserialize method implementations
 * 
 * @author pankaj
 * 
 */
public class SerializationUtil {

	// deserialize to Object from given file
	public static Object deserialize(String fileName) throws IOException,
			ClassNotFoundException {
		FileInputStream fis = new FileInputStream(fileName);
		ObjectInputStream ois = new ObjectInputStream(fis);
		Object obj = ois.readObject();
		ois.close();
		return obj;
	}

	// serialize the given object and save it to file
	public static void serialize(Object obj, String fileName)
			throws IOException {
		FileOutputStream fos = new FileOutputStream(fileName);
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		oos.writeObject(obj);

		fos.close();
	}

}
Notice that the method arguments work with Object that is the base class of any java object. It’s written in this way to be generic in 
nature.

Now let’s write a test program to see Java Serialization in action.


package com.journaldev.serialization;

import java.io.IOException;

public class SerializationTest {
	
	public static void main(String[] args) {
		String fileName="employee.ser";
		Employee emp = new Employee();
		emp.setId(100);
		emp.setName("Pankaj");
		emp.setSalary(5000);
		
		//serialize to file
		try {
			SerializationUtil.serialize(emp, fileName);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
		
		Employee empNew = null;
		try {
			empNew = (Employee) SerializationUtil.deserialize(fileName);
		} catch (ClassNotFoundException | IOException e) {
			e.printStackTrace();
		}
		
		System.out.println("emp Object::"+emp);
		System.out.println("empNew Object::"+empNew);
	}
}
When we run above test program for serialization in java, we get following output.


emp Object::Employee{name=Pankaj,id=100,salary=5000}
empNew Object::Employee{name=Pankaj,id=100,salary=0}
Since salary is a transient variable, it’s value was not saved to file and hence not retrieved in the new object. Similarly static variable values are also not serialized since they belongs to class and not object.


Class Refactoring with Serialization and serialVersionUID :

Serialization in java permits some changes in the java class if they can be ignored. Some of the changes in class that will not affect 
the deserialization process are:

Adding new variables to the class
Changing the variables from transient to non-transient, for serialization it’s like having a new field.
Changing the variable from static to non-static, for serialization it’s like having a new field.
But for all these changes to work, the java class should have serialVersionUID defined for the class. Let’s write a test class just for 
deserialization of the already serialized file from previous test class.


package com.journaldev.serialization;

import java.io.IOException;

public class DeserializationTest {

	public static void main(String[] args) {

		String fileName="employee.ser";
		Employee empNew = null;
		
		try {
			empNew = (Employee) SerializationUtil.deserialize(fileName);
		} catch (ClassNotFoundException | IOException e) {
			e.printStackTrace();
		}
		
		System.out.println("empNew Object::"+empNew);
		
	}
}
Now uncomment the “password” variable and it’s getter-setter methods from Employee class and run it. You will get below exception;


java.io.InvalidClassException: com.journaldev.serialization.Employee; local class incompatible: stream classdesc serialVersionUID = -6470090944414208496, local class serialVersionUID = -6234198221249432383
	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:604)
	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1601)
	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1514)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1750)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1347)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:369)
	at com.journaldev.serialization.SerializationUtil.deserialize(SerializationUtil.java:22)
	at com.journaldev.serialization.DeserializationTest.main(DeserializationTest.java:13)
empNew Object::null
The reason is clear that serialVersionUID of the previous class and new class are different. Actually if the class doesn’t define 
serialVersionUID, it’s getting calculated automatically and assigned to the class. Java uses class variables, methods, class name,
 package etc to generate this unique long number. If you are working with any IDE, you will automatically get a warning that 
 “The serializable class Employee does not declare a static final serialVersionUID field of type long”.

We can use java utility “serialver” to generate the class serialVersionUID, for Employee class we can run it with below command.


SerializationExample/bin$serialver -classpath . com.journaldev.serialization.Employee
Note that it’s not required that the serial version is generated from this program itself, we can assign this value as we want. It just need to be there to let deserialization process know that the new class is the new version of the same class and should be deserialized of possible.

For example, uncomment only the serialVersionUID field from the Employee class and run SerializationTest program. Now uncomment the password field from Employee class and run the DeserializationTest program and you will see that the object stream is deserialized successfully because the change in Employee class is compatible with serialization process.


Java Externalizable Interface :

If you notice the java serialization process, it’s done automatically. Sometimes we want to obscure the object data to maintain it’s 
integrity. We can do this by implementing java.io.Externalizable interface and provide implementation of writeExternal() and readExternal() methods to be used in serialization process.


package com.journaldev.externalization;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

public class Person implements Externalizable{

	private int id;
	private String name;
	private String gender;
	
	@Override
	public void writeExternal(ObjectOutput out) throws IOException {
		out.writeInt(id);
		out.writeObject(name+"xyz");
		out.writeObject("abc"+gender);
	}

	@Override
	public void readExternal(ObjectInput in) throws IOException,
			ClassNotFoundException {
		id=in.readInt();
		//read in the same order as written
		name=(String) in.readObject();
		if(!name.endsWith("xyz")) throw new IOException("corrupted data");
		name=name.substring(0, name.length()-3);
		gender=(String) in.readObject();
		if(!gender.startsWith("abc")) throw new IOException("corrupted data");
		gender=gender.substring(3);
	}

	@Override
	public String toString(){
		return "Person{id="+id+",name="+name+",gender="+gender+"}";
	}
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getGender() {
		return gender;
	}

	public void setGender(String gender) {
		this.gender = gender;
	}

}
Notice that I have changed the field values before converting it to Stream and then while reading reversed the changes. In this way, 
we can maintain data integrity of some sorts. We can throw exception if after reading the stream data, the integrity checks fail. 
Let’s write a test program to see it in action.


package com.journaldev.externalization;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class ExternalizationTest {

	public static void main(String[] args) {
		
		String fileName = "person.ser";
		Person person = new Person();
		person.setId(1);
		person.setName("Pankaj");
		person.setGender("Male");
		
		try {
			FileOutputStream fos = new FileOutputStream(fileName);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
		    oos.writeObject(person);
		    oos.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		FileInputStream fis;
		try {
			fis = new FileInputStream(fileName);
			ObjectInputStream ois = new ObjectInputStream(fis);
		    Person p = (Person)ois.readObject();
		    ois.close();
		    System.out.println("Person Object Read="+p);
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}
	    
	}
}
When we run above program, we get following output.


Person Object Read=Person{id=1,name=Pankaj,gender=Male}
So which one is better to be used for serialization in java. Actually it’s better to use Serializable interface and by the time we reach 
at the end of article, you will know why.


Java Serialization Methods :

We have seen that serialization in java is automatic and all we need is implementing Serializable interface. The implementation is 
present in the ObjectInputStream and ObjectOutputStream classes. But what if we want to change the way we are saving data, for example 
we have some sensitive information in the object and before saving/retrieving we want to encrypt/decrypt it. That’s why there are 
four methods that we can provide in the class to change the serialization behavior.

If these methods are present in the class, they are used for serialization purposes.

readObject(ObjectInputStream ois): If this method is present in the class, ObjectInputStream readObject() method will use this method for 
reading the object from stream.
writeObject(ObjectOutputStream oos): If this method is present in the class, ObjectOutputStream writeObject() method will use this method for writing the object to stream. One of the common usage is to obscure the object variables to maintain data integrity.
Object writeReplace(): If this method is present, then after serialization process this method is called and the object returned is 
serialized to the stream.
Object readResolve(): If this method is present, then after deserialization process, this method is called to return the final object to 
the caller program. One of the usage of this method is to implement Singleton pattern with Serialized classes. 
Read more at Serialization and Singleton.
Usually while implementing above methods, it’s kept as private so that subclasses can’t override them. They are meant for serialization purpose only and keeping them private avoids any security issue.


Serialization with Inheritance :

Sometimes we need to extend a class that doesn’t implement Serializable interface. If we rely on the automatic serialization behavior
 and the superclass has some state, then they will not be converted to stream and hence not retrieved later on.

This is one place, where readObject() and writeObject() methods really help. By providing their implementation, we can save the super 
class state to the stream and then retrieve it later on. Let’s see this in action.


package com.journaldev.serialization.inheritance;

public class SuperClass {

	private int id;
	private String value;
	
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getValue() {
		return value;
	}
	public void setValue(String value) {
		this.value = value;
	}	
}
SuperClass is a simple java bean but it’s not implementing Serializable interface.


package com.journaldev.serialization.inheritance;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectInputValidation;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class SubClass extends SuperClass implements Serializable, ObjectInputValidation{

	private static final long serialVersionUID = -1322322139926390329L;

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	@Override
	public String toString(){
		return "SubClass{id="+getId()+",value="+getValue()+",name="+getName()+"}";
	}
	
	//adding helper method for serialization to save/initialize super class state
	private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException{
		ois.defaultReadObject();
		
		//notice the order of read and write should be same
		setId(ois.readInt());
		setValue((String) ois.readObject());	
	}
	
	private void writeObject(ObjectOutputStream oos) throws IOException{
		oos.defaultWriteObject();
		
		oos.writeInt(getId());
		oos.writeObject(getValue());
	}

	@Override
	public void validateObject() throws InvalidObjectException {
		//validate the object here
		if(name == null || "".equals(name)) throw new InvalidObjectException("name can't be null or empty");
		if(getId() <=0) throw new InvalidObjectException("ID can't be negative or zero");
	}	
}
Notice that order of writing and reading the extra data to the stream should be same. We can put some logic in reading and writing 
data to make it secure.

Also notice that the class is implementing ObjectInputValidation interface. By implementing validateObject() method, we can put some business validations to make sure that the data integrity is not harmed.

Let’s write a test class and see if we can retrieve the super class state from serialized data or not.


package com.journaldev.serialization.inheritance;

import java.io.IOException;

import com.journaldev.serialization.SerializationUtil;

public class InheritanceSerializationTest {

	public static void main(String[] args) {
		String fileName = "subclass.ser";
		
		SubClass subClass = new SubClass();
		subClass.setId(10);
		subClass.setValue("Data");
		subClass.setName("Pankaj");
		
		try {
			SerializationUtil.serialize(subClass, fileName);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
		
		try {
			SubClass subNew = (SubClass) SerializationUtil.deserialize(fileName);
			System.out.println("SubClass read = "+subNew);
		} catch (ClassNotFoundException | IOException e) {
			e.printStackTrace();
		}
	}
}
When we run above class, we get following output.


SubClass read = SubClass{id=10,value=Data,name=Pankaj}
So in this way, we can serialize super class state even though it’s not implementing Serializable interface. This strategy comes handy when the super class is a third-party class that we can’t change.


Serialization Proxy Pattern :

Serialization in java comes with some serious pitfalls such as;

The class structure can’t be changed a lot without breaking the java serialization process. So even though we don’t need some variables later on, we need to keep them just for backward compatibility.
Serialization causes huge security risks, an attacker can change the stream sequence and cause harm to the system. For example, user role is serialized and an attacker change the stream value to make it admin and run malicious code.
Java Serialization Proxy pattern is a way to achieve greater security with Serialization. In this pattern, an inner private static class is used as a proxy class for serialization purpose. This class is designed in the way to maintain the state of the main class. This pattern is implemented by properly implementing readResolve() and writeReplace() methods.

Let us first write a class which implements serialization proxy pattern and then we will analyze it for better understanding.


package com.journaldev.serialization.proxy;

import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;

public class Data implements Serializable{

	private static final long serialVersionUID = 2087368867376448459L;

	private String data;
	
	public Data(String d){
		this.data=d;
	}

	public String getData() {
		return data;
	}

	public void setData(String data) {
		this.data = data;
	}
	
	@Override
	public String toString(){
		return "Data{data="+data+"}";
	}
	
	//serialization proxy class
	private static class DataProxy implements Serializable{
	
		private static final long serialVersionUID = 8333905273185436744L;
		
		private String dataProxy;
		private static final String PREFIX = "ABC";
		private static final String SUFFIX = "DEFG";
		
		public DataProxy(Data d){
			//obscuring data for security
			this.dataProxy = PREFIX + d.data + SUFFIX;
		}
		
		private Object readResolve() throws InvalidObjectException {
			if(dataProxy.startsWith(PREFIX) && dataProxy.endsWith(SUFFIX)){
			return new Data(dataProxy.substring(3, dataProxy.length() -4));
			}else throw new InvalidObjectException("data corrupted");
		}
		
	}
	
	//replacing serialized object to DataProxy object
	private Object writeReplace(){
		return new DataProxy(this);
	}
	
	private void readObject(ObjectInputStream ois) throws InvalidObjectException{
		throw new InvalidObjectException("Proxy is not used, something fishy");
	}
}
Both Data and DataProxy class should implement Serializable interface.
DataProxy should be able to maintain the state of Data object.
DataProxy is inner private static class, so that other classes can’t access it.
DataProxy should have a single constructor that takes Data as argument.
Data class should provide writeReplace() method returning DataProxy instance. So when Data object is serialized, the returned stream is of DataProxy class. However DataProxy class is not visible outside, so it can’t be used directly.
DataProxy class should implement readResolve() method returning Data object. So when Data class is deserialized, internally DataProxy is deserialized and when it’s readResolve() method is called, we get Data object.
Finally implement readObject() method in Data class and throw InvalidObjectException to avoid hackers attack trying to fabricate Data object stream and parse it.
Let’s write a small test to check whether implementation works or not.


package com.journaldev.serialization.proxy;

import java.io.IOException;

import com.journaldev.serialization.SerializationUtil;

public class SerializationProxyTest {

	public static void main(String[] args) {
		String fileName = "data.ser";
		
		Data data = new Data("Pankaj");
		
		try {
			SerializationUtil.serialize(data, fileName);
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		try {
			Data newData = (Data) SerializationUtil.deserialize(fileName);
			System.out.println(newData);
		} catch (ClassNotFoundException | IOException e) {
			e.printStackTrace();
		}
	}

}
When we run above class, we get below output in console.


Data{data=Pankaj}
If you will open the data.ser file, you can see that DataProxy object is saved as stream in the file.

Q31) Co nferring various mapping in hibernate ?

One to many :-

@Entity  
@Table(name="q5991")  
public class Question {    
  
@Id   
@GeneratedValue(strategy=GenerationType.TABLE)  
private int id;    
private String qname;    
  
@OneToMany(cascade = CascadeType.ALL)  
@JoinColumn(name="qid")  
@OrderColumn(name="type")  
private List<Answer> answers;  


 @Entity  
    @Table(name="ans5991")  
    public class Answer {   
    @Id  
    @GeneratedValue(strategy=GenerationType.TABLE)  
      
    private int id;    
    private String answername;    
    private String postedBy;  
 
