SOA vs microservices?
SOA is just a kind of utility anyone can access it.
Microservices:-Its a whole Application

public class MviCatApplication{
@Bean
public RestTemplate getRestTemplate(){
	return new RestTemplate();
}

public static void main(String[] args){
SpringApplication.run(...)
}
}

-Then we will just Autowired RestTemplate in any class and then it will load at once 
@Bean is producer it tells I have this object people will need so execute this method and return .

-RestTemplate will be deprecated at a point and in place of it we can use WebClient.
 WebClient - Asynchronus So in this we have api calls and we dont wait around and we will do other works. So we dont tell what to do but give lambda and instruct what needs to happen when its done
 RestTemplate-Syncronus so in this we say RestTemplate to give me the object and then it will wait around till it gives u the object
 
 webClient-
  in pom we change web dependency to  webflux 
  webClient.Builder builder = WebClient.builder
  Movie movie= webClientBuilder.build().get().uri("http://localhost:8080/api").retrive().bodyToMono(Movie.class).block();
  
  bodyToMono :- its a reactive way to say we are getting the object sometime in future its asyncronus and its like a promise. 
  
  Q-)So why hardcoding url is  wrong?
  - Changes require code update
  - load balancing 
  - dynamic url in clou d
  - Multiple envoirments
  
  SO to make microservices talk or comunicate we use services discovery ie trhey will discover the traget
Q) how we do service discovery?
  -) we have Discover Server and we should register our service their.
  -) then the client will look the discovery server i.e what service it needs and it provide the address of service api
  -)client  send msg to service 2
  
  Spring cloud uses client side discovery-
  
  Spring cloud us eEureka.
  -)Eureka is project that make open source by Netflix OSS 
  -) Netlix created this lib for microservices like Eureka, Ribbon, Hysterix, Zuul and make them open source 
  -) we use spring cli=oud and eureka for register the service and discover them.
   -) Eureka Server is Discovery Server and all the services is like Eureka clients
   
   
   Create Eureka Server
   - pom eureka discoverys 
  
  
 Q) Imp ---> 12 factor App 
 https://12factor.net/
 
 
 Q) Ways to implement ACID transaction?
 1) 2pc :
 Two-Phase Commit Protocol
This mechanism is designed initially for distributed systems. As Microservices architecture inherently distributed systems in nature, we can use the Two-phase commit protocol (or 2PC) as one of the approaches. Primary drivers in a distributed transaction management are the message broker/transaction coordinator.
The distributed transaction contains two steps:
Prepare phase
Commit or Rollback phase
Prepare Phase:
All the participants of a transaction in this phase will be prepared for the commit and inform the transaction coordinator/message broker that they are ready for completing the transaction
Commit or Rollback phase:
In this phase, transaction coordinator will issue one of the commands they are a commit or a rollback to all the participants.
The main issue with the 2PC approach is that it is a bit slow compared to the time for the operation on a single Microservice because it has to coordinate the transaction between services even if all the microservices are on the same network, still operation will be slow. So we need to be careful while implementing this for high demand services.

DrawBack:- its very slow.

2) SAGA principle:
https://dzone.com/articles/saga-pattern-how-to-implement-business-transaction-1